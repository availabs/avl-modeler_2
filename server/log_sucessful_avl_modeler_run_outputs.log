jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_new$ cd ..
jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples$ cd test_prototype_mtc_test/
jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_test$ ;s
bash: syntax error near unexpected token `;'
jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_test$ activitysim run -c configs -d data -o output
activitysim: command not found
jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_test$ conda activate ASIM_DEV_new
(ASIM_DEV_new) jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_test$ activitysim run -c configs -d data -o output
Configured logging using basicConfig
INFO:activitysim:Configured logging using basicConfig
[00:01.03] INFO: Read logging configuration from: configs/logging.yaml
[00:01.03] INFO: SETTING configs_dir: ['configs']
[00:01.03] INFO: SETTING settings_file_name: settings.yaml
[00:01.03] INFO: SETTING data_dir: ['data']
[00:01.03] INFO: SETTING output_dir: output
[00:01.03] INFO: SETTING households_sample_size: 100
[00:01.03] INFO: SETTING chunk_size: 0
[00:01.03] INFO: SETTING chunk_method: hybrid_uss
[00:01.03] INFO: SETTING chunk_training_mode: disabled
[00:01.03] INFO: SETTING multiprocess: None
[00:01.03] INFO: SETTING num_processes: None
[00:01.03] INFO: SETTING resume_after: None
[00:01.03] INFO: SETTING trace_hh_id: 982875
[00:01.03] INFO: ENV MKL_NUM_THREADS: None
[00:01.03] INFO: ENV OMP_NUM_THREADS: None
[00:01.03] INFO: ENV OPENBLAS_NUM_THREADS: None
[00:01.03] INFO: NUMPY blas_info libraries: ['cblas', 'blas', 'cblas', 'blas']
[00:01.03] INFO: NUMPY blas_opt_info libraries: ['cblas', 'blas', 'cblas', 'blas']
[00:01.03] INFO: NUMPY lapack_info libraries: ['lapack', 'blas', 'lapack', 'blas']
[00:01.03] INFO: NUMPY lapack_opt_info libraries: ['lapack', 'blas', 'lapack', 'blas', 'cblas', 'blas', 'cblas', 'blas']
[00:01.03] INFO: run single process simulation
[00:01.05] INFO: Time to execute open_pipeline : 0.011 seconds (0.0 minutes)
[00:01.06] INFO: preload_injectables
[00:01.06] INFO: Time to execute preload_injectables : 0.013 seconds (0.0 minutes)
[00:01.08] INFO: #run_model running step initialize_landuse
Running step 'initialize_landuse'
[00:01.09] INFO: Reading CSV file data/land_use.csv
[00:01.10] INFO: loaded land_use (25, 24)
[00:01.10] INFO: initialize_landuse.annotate_tables - annotating land_use SPEC annotate_landuse
[00:01.11] INFO: Network_LOS using skim_dict_factory: NumpyArraySkimFactory
[00:01.37] INFO: allocate_skim_buffer shared False taz shape (826, 25, 25) total size: 2_065_000 (2.1 MB)
[00:01.37] INFO: _read_skims_from_omx data/skims.omx
[00:01.77] INFO: _read_skims_from_omx loaded 826 skims from data/skims.omx
[00:01.77] INFO: writing skim cache taz (826, 25, 25) to output/cache/cached_taz.mmap
[00:01.78] INFO: load_skims_to_buffer taz shape (826, 25, 25)
[00:01.78] INFO: get_skim_data taz SkimData shape (826, 25, 25)
[00:01.78] INFO: SkimDict init taz
[00:01.78] INFO: SkimDict.build_3d_skim_block_offset_table registered 167 3d keys
Time to execute step 'initialize_landuse': 0.70 s
Total time to execute iteration 1 with iteration value None: 0.70 s
[00:01.85] INFO: #run_model running step initialize_households
Running step 'initialize_households'
[00:01.85] INFO: Reading CSV file data/households.csv
[00:01.88] INFO: full household list contains 5000 households
[00:01.88] INFO: sampling 100 of 5000 households
[00:01.88] INFO: loaded households (100, 7)
[00:01.88] INFO: tracing household id 982875 in 100 households
[00:01.89] INFO: Reading CSV file data/persons.csv
[00:01.91] INFO: loaded persons (167, 7)
[00:01.92] INFO: initialize_households.annotate_tables - annotating persons SPEC annotate_persons
[00:01.98] INFO: initialize_households.annotate_tables - annotating households SPEC annotate_households
[00:02.04] INFO: initialize_households.annotate_tables - annotating persons SPEC annotate_persons_after_hh
Time to execute step 'initialize_households': 0.23 s
Total time to execute iteration 1 with iteration value None: 0.23 s
[00:02.17] INFO: #run_model running step compute_accessibility
Running step 'compute_accessibility'
[00:02.18] INFO: Running compute_accessibility with 25 orig zones 25 dest zones
[00:02.18] INFO: compute_accessibility Running adaptive_chunked_choosers with 25 choosers
[00:02.18] INFO: Running chunk 1 of 1 with 25 of 25 choosers
[00:02.18] INFO: Running compute_accessibility with 25 orig zones 25 dest zones
[00:02.18] INFO: compute_accessibility: merge land_use_columns into od_df
[00:02.18] INFO: compute_accessibility: assign.assign_variables
[00:02.18] INFO: compute_accessibility.assign_variables _auPkTime = skim_od[('SOVTOLL_TIME', 'AM')] + skim_do[('SOVTOLL_TIME', 'PM')]
[00:02.19] INFO: compute_accessibility.assign_variables _decay = exp(_auPkTime * dispersion_parameter_automobile)
[00:02.19] INFO: compute_accessibility.assign_variables auPkRetail = df.RETEMPN * _decay
[00:02.19] INFO: compute_accessibility.assign_variables auPkTotal = df.TOTEMP * _decay
[00:02.19] INFO: compute_accessibility.assign_variables _auOpTime = skim_od[('SOVTOLL_TIME', 'MD')] + skim_do[('SOVTOLL_TIME', 'MD')]
[00:02.19] INFO: compute_accessibility.assign_variables _decay = exp(_auOpTime * dispersion_parameter_automobile)
[00:02.19] INFO: compute_accessibility.assign_variables auOpRetail = df.RETEMPN * _decay
[00:02.19] INFO: compute_accessibility.assign_variables auOpTotal = df.TOTEMP * _decay
[00:02.19] INFO: compute_accessibility.assign_variables _inVehicleTime = skim_od[('WLK_TRN_WLK_IVT', 'AM')]
[00:02.19] INFO: compute_accessibility.assign_variables _outOfVehicleTime = skim_od[('WLK_TRN_WLK_IWAIT', 'AM')] + skim_od[('WLK_TRN_WLK_XWAIT', 'AM')] + skim_od[('WLK_TRN_WLK_WACC', 'AM')] + skim_od[('WLK_TRN_WLK_WAUX', 'AM')] + skim_od[('WLK_TRN_WLK_WEGR', 'AM')]
[00:02.19] INFO: compute_accessibility.assign_variables _trPkTime_od = (_inVehicleTime + out_of_vehicle_time_weight * _outOfVehicleTime) / TRANSIT_SCALE_FACTOR
[00:02.19] INFO: compute_accessibility.assign_variables _inVehicleTime = skim_do[('WLK_TRN_WLK_IVT', 'PM')]
[00:02.19] INFO: compute_accessibility.assign_variables _outOfVehicleTime = skim_do[('WLK_TRN_WLK_IWAIT', 'PM')] + skim_do[('WLK_TRN_WLK_XWAIT', 'PM')] + skim_do[('WLK_TRN_WLK_WACC', 'PM')] + skim_do[('WLK_TRN_WLK_WAUX', 'PM')] + skim_do[('WLK_TRN_WLK_WEGR', 'PM')]
[00:02.20] INFO: compute_accessibility.assign_variables _trPkTime_do = (_inVehicleTime + out_of_vehicle_time_weight * _outOfVehicleTime) / TRANSIT_SCALE_FACTOR
[00:02.20] INFO: compute_accessibility.assign_variables _trPkTime = (_trPkTime_od + _trPkTime_do).clip(0)
[00:02.20] INFO: compute_accessibility.assign_variables _rt_available = (_trPkTime_od > 0) & (_trPkTime_do > 0)
[00:02.20] INFO: compute_accessibility.assign_variables _decay = _rt_available * exp(_trPkTime * dispersion_parameter_transit)
[00:02.20] INFO: compute_accessibility.assign_variables trPkRetail = df.RETEMPN * _decay
[00:02.20] INFO: compute_accessibility.assign_variables trPkTotal = df.TOTEMP * _decay
[00:02.20] INFO: compute_accessibility.assign_variables _inVehicleTime = skim_od[('WLK_TRN_WLK_IVT', 'MD')]
[00:02.20] INFO: compute_accessibility.assign_variables _outOfVehicleTime = skim_od[('WLK_TRN_WLK_IWAIT', 'MD')] + skim_od[('WLK_TRN_WLK_XWAIT', 'MD')] + skim_od[('WLK_TRN_WLK_WACC', 'MD')] + skim_od[('WLK_TRN_WLK_WAUX', 'MD')] + skim_od[('WLK_TRN_WLK_WEGR', 'MD')]
[00:02.20] INFO: compute_accessibility.assign_variables _trOpTime_od = (_inVehicleTime + out_of_vehicle_time_weight * _outOfVehicleTime) / TRANSIT_SCALE_FACTOR
[00:02.20] INFO: compute_accessibility.assign_variables _inVehicleTime = skim_do[('WLK_TRN_WLK_IVT', 'MD')]
[00:02.20] INFO: compute_accessibility.assign_variables _outOfVehicleTime = skim_do[('WLK_TRN_WLK_IWAIT', 'MD')] + skim_do[('WLK_TRN_WLK_XWAIT', 'MD')] + skim_do[('WLK_TRN_WLK_WACC', 'MD')] + skim_do[('WLK_TRN_WLK_WAUX', 'MD')] + skim_do[('WLK_TRN_WLK_WEGR', 'MD')]
[00:02.20] INFO: compute_accessibility.assign_variables _trOpTime_do = (_inVehicleTime + out_of_vehicle_time_weight * _outOfVehicleTime) / TRANSIT_SCALE_FACTOR
[00:02.20] INFO: compute_accessibility.assign_variables _trOpTime = (_trOpTime_od + _trOpTime_do).clip(0)
[00:02.21] INFO: compute_accessibility.assign_variables _rt_available = (_trOpTime_od > 0) & (_trOpTime_do > 0)
[00:02.21] INFO: compute_accessibility.assign_variables _decay = _rt_available * exp(_trOpTime * dispersion_parameter_transit)
[00:02.21] INFO: compute_accessibility.assign_variables trOpRetail = df.RETEMPN * _decay
[00:02.21] INFO: compute_accessibility.assign_variables trOpTotal = df.TOTEMP * _decay
[00:02.21] INFO: compute_accessibility.assign_variables _nmDist = skim_od['DISTWALK'] + skim_do['DISTWALK']
[00:02.21] INFO: compute_accessibility.assign_variables _rt_available = _nmDist <= maximum_walk_distance
[00:02.21] INFO: compute_accessibility.assign_variables _decay = _rt_available * exp(_nmDist * dispersion_parameter_walk)
[00:02.21] INFO: compute_accessibility.assign_variables nmRetail = df.RETEMPN * _decay
[00:02.21] INFO: compute_accessibility.assign_variables nmTotal = df.TOTEMP * _decay
[00:02.21] INFO: compute_accessibility: have results
[00:02.21] INFO: compute_accessibility computed accessibilities (25, 10)
Time to execute step 'compute_accessibility': 0.04 s
Total time to execute iteration 1 with iteration value None: 0.04 s
[00:02.27] INFO: #run_model running step school_location
Running step 'school_location'
[00:02.29] INFO: Running school_location.i1.sample.university with 17 persons
[00:02.30] INFO: school_location.i1.sample.university.interaction_sample Running adaptive_chunked_choosers with 17 choosers
[00:02.30] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:02.31] INFO: Running eval_interaction_utilities on 102 rows
[00:02.36] INFO: Running school_location.i1.logsums.university with 44 rows
[00:02.53] INFO: school_location.i1.logsums.university.compute_logsums Running adaptive_chunked_choosers with 44 choosers
[00:02.53] INFO: Running chunk 1 of 1 with 44 of 44 choosers
[00:03.03] INFO: Running school_location.i1.simulate.university with 17 persons
[00:03.03] INFO: school_location.i1.simulate.university.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 17 choosers and 44 alternatives
[00:03.03] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:03.04] INFO: Running eval_interaction_utilities on 44 rows
[00:03.07] INFO: Running school_location.i1.sample.highschool with 5 persons
[00:03.07] INFO: school_location.i1.sample.highschool.interaction_sample Running adaptive_chunked_choosers with 5 choosers
[00:03.07] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:03.08] INFO: Running eval_interaction_utilities on 10 rows
[00:03.11] INFO: Running school_location.i1.logsums.highschool with 5 rows
[00:03.26] INFO: school_location.i1.logsums.highschool.compute_logsums Running adaptive_chunked_choosers with 5 choosers
[00:03.26] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:03.58] INFO: Running school_location.i1.simulate.highschool with 5 persons
[00:03.59] INFO: school_location.i1.simulate.highschool.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 5 choosers and 5 alternatives
[00:03.59] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:03.59] INFO: Running eval_interaction_utilities on 5 rows
[00:03.60] INFO: Running school_location.i1.sample.gradeschool with 17 persons
[00:03.61] INFO: school_location.i1.sample.gradeschool.interaction_sample Running adaptive_chunked_choosers with 17 choosers
[00:03.61] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:03.61] INFO: Running eval_interaction_utilities on 425 rows
[00:03.69] INFO: Running school_location.i1.logsums.gradeschool with 168 rows
[00:03.89] INFO: school_location.i1.logsums.gradeschool.compute_logsums Running adaptive_chunked_choosers with 168 choosers
[00:03.89] INFO: Running chunk 1 of 1 with 168 of 168 choosers
[00:04.24] INFO: Running school_location.i1.simulate.gradeschool with 17 persons
[00:04.26] INFO: school_location.i1.simulate.gradeschool.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 17 choosers and 168 alternatives
[00:04.26] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:04.27] INFO: Running eval_interaction_utilities on 168 rows
[00:04.32] INFO: write_trace_files iteration 1
[00:04.35] INFO: school_location_logsum top 10 value counts:
10.893995    1
12.125021    1
20.447053    1
10.539866    1
20.920595    1
20.361189    1
19.950674    1
10.770754    1
10.165962    1
20.936072    1
Name: logsum, dtype: int64
Time to execute step 'school_location': 2.07 s
Total time to execute iteration 1 with iteration value None: 2.07 s
[00:04.42] INFO: #run_model running step workplace_location
Running step 'workplace_location'
[00:04.44] INFO: Running workplace_location.i1.sample.work_low with 37 persons
[00:04.44] INFO: workplace_location.i1.sample.work_low.interaction_sample Running adaptive_chunked_choosers with 37 choosers
[00:04.44] INFO: Running chunk 1 of 1 with 37 of 37 choosers
[00:04.45] INFO: Running eval_interaction_utilities on 925 rows
[00:04.49] INFO: Running workplace_location.i1.logsums.work_low with 504 rows
[00:04.64] INFO: workplace_location.i1.logsums.work_low.compute_logsums Running adaptive_chunked_choosers with 504 choosers
[00:04.64] INFO: Running chunk 1 of 1 with 504 of 504 choosers
[00:05.01] INFO: Running workplace_location.i1.simulate.work_low with 37 persons
[00:05.03] INFO: workplace_location.i1.simulate.work_low.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 37 choosers and 504 alternatives
[00:05.03] INFO: Running chunk 1 of 1 with 37 of 37 choosers
[00:05.04] INFO: Running eval_interaction_utilities on 504 rows
[00:05.08] INFO: Running workplace_location.i1.sample.work_med with 26 persons
[00:05.08] INFO: workplace_location.i1.sample.work_med.interaction_sample Running adaptive_chunked_choosers with 26 choosers
[00:05.08] INFO: Running chunk 1 of 1 with 26 of 26 choosers
[00:05.09] INFO: Running eval_interaction_utilities on 650 rows
[00:05.14] INFO: Running workplace_location.i1.logsums.work_med with 367 rows
[00:05.33] INFO: workplace_location.i1.logsums.work_med.compute_logsums Running adaptive_chunked_choosers with 367 choosers
[00:05.33] INFO: Running chunk 1 of 1 with 367 of 367 choosers
[00:05.85] INFO: Running workplace_location.i1.simulate.work_med with 26 persons
[00:05.85] INFO: workplace_location.i1.simulate.work_med.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 26 choosers and 367 alternatives
[00:05.85] INFO: Running chunk 1 of 1 with 26 of 26 choosers
[00:05.86] INFO: Running eval_interaction_utilities on 367 rows
[00:05.89] INFO: Running workplace_location.i1.sample.work_high with 16 persons
[00:05.90] INFO: workplace_location.i1.sample.work_high.interaction_sample Running adaptive_chunked_choosers with 16 choosers
[00:05.90] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:05.90] INFO: Running eval_interaction_utilities on 400 rows
[00:05.94] INFO: Running workplace_location.i1.logsums.work_high with 226 rows
[00:06.09] INFO: workplace_location.i1.logsums.work_high.compute_logsums Running adaptive_chunked_choosers with 226 choosers
[00:06.09] INFO: Running chunk 1 of 1 with 226 of 226 choosers
[00:06.44] INFO: Running workplace_location.i1.simulate.work_high with 16 persons
[00:06.46] INFO: workplace_location.i1.simulate.work_high.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 16 choosers and 226 alternatives
[00:06.46] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:06.47] INFO: Running eval_interaction_utilities on 226 rows
[00:06.51] INFO: Running workplace_location.i1.sample.work_veryhigh with 18 persons
[00:06.52] INFO: workplace_location.i1.sample.work_veryhigh.interaction_sample Running adaptive_chunked_choosers with 18 choosers
[00:06.52] INFO: Running chunk 1 of 1 with 18 of 18 choosers
[00:06.52] INFO: Running eval_interaction_utilities on 450 rows
[00:06.55] INFO: Running workplace_location.i1.logsums.work_veryhigh with 253 rows
[00:06.71] INFO: workplace_location.i1.logsums.work_veryhigh.compute_logsums Running adaptive_chunked_choosers with 253 choosers
[00:06.71] INFO: Running chunk 1 of 1 with 253 of 253 choosers
[00:07.07] INFO: Running workplace_location.i1.simulate.work_veryhigh with 18 persons
[00:07.09] INFO: workplace_location.i1.simulate.work_veryhigh.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 18 choosers and 253 alternatives
[00:07.09] INFO: Running chunk 1 of 1 with 18 of 18 choosers
[00:07.10] INFO: Running eval_interaction_utilities on 253 rows
[00:07.14] INFO: write_trace_files iteration 1
[00:07.19] INFO: workplace_location_logsum top 10 value counts:
15.437107    1
14.391639    1
15.663789    1
15.656738    1
15.699269    1
15.725096    1
15.549150    1
15.551084    1
13.812699    1
13.914080    1
Name: logsum, dtype: int64
Time to execute step 'workplace_location': 2.77 s
Total time to execute iteration 1 with iteration value None: 2.77 s
[00:07.28] INFO: #run_model running step auto_ownership_simulate
Running step 'auto_ownership_simulate'
[00:07.30] INFO: Running auto_ownership_simulate with 100 households
[00:07.30] INFO: auto_ownership_simulate.simple_simulate Running adaptive_chunked_choosers with 100 choosers
[00:07.30] INFO: Running chunk 1 of 1 with 100 of 100 choosers
[00:07.37] INFO: auto_ownership top 10 value counts:
0    60
1    40
Name: auto_ownership, dtype: int64
Time to execute step 'auto_ownership_simulate': 0.09 s
Total time to execute iteration 1 with iteration value None: 0.09 s
[00:07.44] INFO: #run_model running step free_parking
Running step 'free_parking'
[00:07.45] INFO: Running free_parking with 97 persons
[00:07.48] INFO: free_parking.simple_simulate Running adaptive_chunked_choosers with 97 choosers
[00:07.48] INFO: Running chunk 1 of 1 with 97 of 97 choosers
[00:07.50] INFO: free_parking top 10 value counts:
False    163
True       4
Name: free_parking_at_work, dtype: int64
Time to execute step 'free_parking': 0.07 s
Total time to execute iteration 1 with iteration value None: 0.07 s
[00:07.57] INFO: #run_model running step cdap_simulate
Running step 'cdap_simulate'
[00:07.61] INFO: Pre-building cdap specs
[00:07.71] INFO: Time to execute build_cdap_spec hh_size 2 : 0.1 seconds (0.0 minutes)
[00:08.00] INFO: Time to execute build_cdap_spec hh_size 3 : 0.29 seconds (0.0 minutes)
[00:08.65] INFO: Time to execute build_cdap_spec hh_size 4 : 0.652 seconds (0.0 minutes)
[00:10.11] INFO: Time to execute build_cdap_spec hh_size 5 : 1.453 seconds (0.0 minutes)
[00:10.17] INFO: Running cdap_simulate with 167 persons
[00:10.17] INFO: cdap.cdap Running chunk 1 of 1 with 100 of 100 choosers
[00:11.99] INFO: cdap_activity top 10 value counts:
M    89
N    48
H    30
Name: cdap_activity, dtype: int64
[00:12.01] INFO: cdap crosstabs:
cdap_activity   H   M   N  All
ptype                         
1               4  42   6   52
2               8  19   7   34
3               1  11   5   17
4               4   0  17   21
5               9   0  12   21
6               4   1   0    5
7               0  10   1   11
8               0   6   0    6
All            30  89  48  167
Time to execute step 'cdap_simulate': 4.44 s
Total time to execute iteration 1 with iteration value None: 4.44 s
[00:12.09] INFO: #run_model running step mandatory_tour_frequency
Running step 'mandatory_tour_frequency'
[00:12.10] INFO: Running mandatory_tour_frequency with 89 persons
[00:12.12] INFO: mandatory_tour_frequency.simple_simulate Running adaptive_chunked_choosers with 89 choosers
[00:12.12] INFO: Running chunk 1 of 1 with 89 of 89 choosers
[00:12.48] INFO: mandatory_tour_frequency top 10 value counts:
                   78
work1              61
school1            22
work_and_school     4
work2               2
Name: mandatory_tour_frequency, dtype: int64
Time to execute step 'mandatory_tour_frequency': 0.39 s
Total time to execute iteration 1 with iteration value None: 0.39 s
[00:12.56] INFO: #run_model running step mandatory_tour_scheduling
Running step 'mandatory_tour_scheduling'
[00:12.59] DEBUG: @inject timetable
[00:12.62] INFO: Running mandatory_tour_scheduling with 95 tours
[00:12.62] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work schedule_tours running 67 tour choices
[00:12.62] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work Running adaptive_chunked_choosers with 67 choosers
[00:12.63] INFO: Running chunk 1 of 1 with 67 of 67 choosers
[00:12.63] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work schedule_tours running 67 tour choices
[00:12.64] INFO: tdd_alt_segments specified for representative logsums
[00:12.65] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work.compute_logsums compute_logsums deduped_alt_tdds reduced number of rows by 92.11% from 12730 to 1005 compared to USE_BRUTE_FORCE_TO_COMPUTE_LOGSUMS
[00:12.67] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work.compute_logsums.logsums compute_logsums for 1005 choosers 1005 alts
[00:12.88] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work.compute_logsums.logsums Running adaptive_chunked_choosers with 1005 choosers
[00:12.88] INFO: Running chunk 1 of 1 with 1005 of 1005 choosers
[00:13.42] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.work.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 67 choosers and 12730 alternatives
[00:13.42] INFO: Running chunk 1 of 1 with 67 of 67 choosers
[00:13.43] INFO: Running eval_interaction_utilities on 12730 rows
[00:13.65] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school schedule_tours running 17 tour choices
[00:13.65] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school Running adaptive_chunked_choosers with 17 choosers
[00:13.65] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:13.65] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school schedule_tours running 17 tour choices
[00:13.66] INFO: tdd_alt_segments specified for representative logsums
[00:13.67] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school.compute_logsums compute_logsums deduped_alt_tdds reduced number of rows by 92.11% from 3230 to 255 compared to USE_BRUTE_FORCE_TO_COMPUTE_LOGSUMS
[00:13.68] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school.compute_logsums.logsums compute_logsums for 255 choosers 255 alts
[00:13.84] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school.compute_logsums.logsums Running adaptive_chunked_choosers with 255 choosers
[00:13.84] INFO: Running chunk 1 of 1 with 255 of 255 choosers
[00:14.23] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.school.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 17 choosers and 3230 alternatives
[00:14.23] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:14.25] INFO: Running eval_interaction_utilities on 3230 rows
[00:14.38] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ schedule_tours running 5 tour choices
[00:14.38] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ Running adaptive_chunked_choosers with 5 choosers
[00:14.38] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:14.38] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ schedule_tours running 5 tour choices
[00:14.39] INFO: tdd_alt_segments specified for representative logsums
[00:14.39] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ.compute_logsums compute_logsums deduped_alt_tdds reduced number of rows by 92.11% from 950 to 75 compared to USE_BRUTE_FORCE_TO_COMPUTE_LOGSUMS
[00:14.41] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ.compute_logsums.logsums compute_logsums for 75 choosers 75 alts
[00:14.57] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ.compute_logsums.logsums Running adaptive_chunked_choosers with 75 choosers
[00:14.57] INFO: Running chunk 1 of 1 with 75 of 75 choosers
[00:14.94] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.univ.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 5 choosers and 950 alternatives
[00:14.94] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:14.95] INFO: Running eval_interaction_utilities on 950 rows
[00:15.08] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work schedule_tours running 2 tour choices
[00:15.08] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work Running adaptive_chunked_choosers with 2 choosers
[00:15.08] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:15.08] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work schedule_tours running 2 tour choices
[00:15.08] INFO: tdd_alt_segments specified for representative logsums
[00:15.09] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work.compute_logsums compute_logsums deduped_alt_tdds reduced number of rows by 89.71% from 175 to 18 compared to USE_BRUTE_FORCE_TO_COMPUTE_LOGSUMS
[00:15.10] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work.compute_logsums.logsums compute_logsums for 18 choosers 18 alts
[00:15.25] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work.compute_logsums.logsums Running adaptive_chunked_choosers with 18 choosers
[00:15.25] INFO: Running chunk 1 of 1 with 18 of 18 choosers
[00:15.58] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.work.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 175 alternatives
[00:15.58] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:15.58] INFO: Running eval_interaction_utilities on 175 rows
[00:15.69] INFO: skipping empty segment school
[00:15.69] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ schedule_tours running 4 tour choices
[00:15.69] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ Running adaptive_chunked_choosers with 4 choosers
[00:15.69] INFO: Running chunk 1 of 1 with 4 of 4 choosers
[00:15.69] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ schedule_tours running 4 tour choices
[00:15.70] INFO: tdd_alt_segments specified for representative logsums
[00:15.70] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ.compute_logsums compute_logsums deduped_alt_tdds reduced number of rows by 90.16% from 366 to 36 compared to USE_BRUTE_FORCE_TO_COMPUTE_LOGSUMS
[00:15.72] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ.compute_logsums.logsums compute_logsums for 36 choosers 36 alts
[00:15.87] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ.compute_logsums.logsums Running adaptive_chunked_choosers with 36 choosers
[00:15.87] INFO: Running chunk 1 of 1 with 36 of 36 choosers
[00:16.20] INFO: mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.univ.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 4 choosers and 366 alternatives
[00:16.20] INFO: Running chunk 1 of 1 with 4 of 4 choosers
[00:16.20] INFO: Running eval_interaction_utilities on 366 rows
Time to execute step 'mandatory_tour_scheduling': 3.75 s
Total time to execute iteration 1 with iteration value None: 3.75 s
[00:16.38] INFO: #run_model running step joint_tour_frequency
Running step 'joint_tour_frequency'
[00:16.39] INFO: Running joint_tour_frequency with 36 multi-person households
[00:16.42] DEBUG: @inject timetable
[00:16.54] INFO: joint_tour_frequency.simple_simulate Running adaptive_chunked_choosers with 36 choosers
[00:16.54] INFO: Running chunk 1 of 1 with 36 of 36 choosers
[00:16.67] WARNING: register tours: no rows with household_id in [982875].
[00:16.68] INFO: joint_tour_frequency top 10 value counts:
0_tours    97
1_Eat       1
1_Shop      1
1_Disc      1
Name: joint_tour_frequency, dtype: int64
Time to execute step 'joint_tour_frequency': 0.30 s
Total time to execute iteration 1 with iteration value None: 0.30 s
[00:16.76] INFO: #run_model running step joint_tour_composition
Running step 'joint_tour_composition'
[00:16.76] INFO: Running joint_tour_composition with 3 joint tours
[00:16.78] DEBUG: @inject timetable
[00:16.84] INFO: joint_tour_composition.simple_simulate Running adaptive_chunked_choosers with 3 choosers
[00:16.84] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:16.88] INFO: joint_tour_composition top 10 value counts:
adults      2
children    1
Name: composition, dtype: int64
Time to execute step 'joint_tour_composition': 0.12 s
Total time to execute iteration 1 with iteration value None: 0.12 s
[00:16.95] INFO: #run_model running step joint_tour_participation
Running step 'joint_tour_participation'
[00:16.97] WARNING: register joint_tour_participants: no rows with household_id in [982875].
[00:16.97] INFO: Running joint_tours_participation with 8 potential participants (candidates)
[00:16.99] DEBUG: @inject timetable
[00:17.03] INFO: joint_tour_participation Running chunk 1 of 1 with 3 of 3 choosers
[00:17.20] INFO: joint_tour_participation.eval_mnl.participants_chooser 3 joint tours to satisfy.
[00:17.21] INFO: joint_tour_participation.eval_mnl.participants_chooser 1 iterations to satisfy all joint tours.
Time to execute step 'joint_tour_participation': 0.30 s
Total time to execute iteration 1 with iteration value None: 0.30 s
[00:17.33] INFO: #run_model running step joint_tour_destination
Running step 'joint_tour_destination'
[00:17.36] INFO: running joint_tour_destination.shopping.sample with 1 tours
[00:17.36] INFO: joint_tour_destination.shopping.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:17.36] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:17.37] INFO: Running eval_interaction_utilities on 25 rows
[00:17.40] INFO: Running joint_tour_destination.shopping.logsums with 11 rows
[00:17.57] INFO: joint_tour_destination.shopping.logsums.compute_logsums Running adaptive_chunked_choosers with 11 choosers
[00:17.57] INFO: Running chunk 1 of 1 with 11 of 11 choosers
[00:17.94] INFO: Running tour_destination_simulate with 1 persons
[00:17.94] INFO: joint_tour_destination.shopping.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 11 alternatives
[00:17.94] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:17.94] INFO: Running eval_interaction_utilities on 11 rows
[00:17.95] INFO: joint_tour_destination skipping segment othmaint: no choosers
[00:17.96] INFO: running joint_tour_destination.othdiscr.sample with 1 tours
[00:17.96] INFO: joint_tour_destination.othdiscr.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:17.96] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:17.96] INFO: Running eval_interaction_utilities on 25 rows
[00:18.00] INFO: Running joint_tour_destination.othdiscr.logsums with 15 rows
[00:18.14] INFO: joint_tour_destination.othdiscr.logsums.compute_logsums Running adaptive_chunked_choosers with 15 choosers
[00:18.14] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:18.46] INFO: Running tour_destination_simulate with 1 persons
[00:18.46] INFO: joint_tour_destination.othdiscr.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 15 alternatives
[00:18.46] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:18.46] INFO: Running eval_interaction_utilities on 15 rows
[00:18.48] INFO: running joint_tour_destination.eatout.sample with 1 tours
[00:18.48] INFO: joint_tour_destination.eatout.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:18.48] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:18.48] INFO: Running eval_interaction_utilities on 25 rows
[00:18.52] INFO: Running joint_tour_destination.eatout.logsums with 16 rows
[00:18.67] INFO: joint_tour_destination.eatout.logsums.compute_logsums Running adaptive_chunked_choosers with 16 choosers
[00:18.67] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:18.99] INFO: Running tour_destination_simulate with 1 persons
[00:18.99] INFO: joint_tour_destination.eatout.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 16 alternatives
[00:18.99] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:18.99] INFO: Running eval_interaction_utilities on 16 rows
[00:19.00] INFO: joint_tour_destination skipping segment social: no choosers
[00:19.00] INFO: joint_tour_destination skipping segment escort: no choosers
[00:19.02] INFO: destination summary:
count     3.000000
mean     14.000000
std       9.539392
min       5.000000
25%       9.000000
50%      13.000000
75%      18.500000
max      24.000000
Name: destination, dtype: float64
Time to execute step 'joint_tour_destination': 1.69 s
Total time to execute iteration 1 with iteration value None: 1.69 s
[00:19.09] INFO: #run_model running step joint_tour_scheduling
Running step 'joint_tour_scheduling'
[00:19.10] INFO: Running joint_tour_scheduling with 3 joint tours
[00:19.12] DEBUG: @inject timetable
[00:19.17] INFO: schedule_tours %s tours not monotonic_increasing - sorting df
[00:19.17] INFO: joint_tour_scheduling.vectorize_joint_tour_scheduling.tour_1 schedule_tours running 3 tour choices
[00:19.17] INFO: joint_tour_scheduling.vectorize_joint_tour_scheduling.tour_1 Running adaptive_chunked_choosers with 3 choosers
[00:19.17] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:19.17] INFO: joint_tour_scheduling.vectorize_joint_tour_scheduling.tour_1 schedule_tours running 3 tour choices
[00:19.18] INFO: joint_tour_scheduling.vectorize_joint_tour_scheduling.tour_1.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 3 choosers and 65 alternatives
[00:19.18] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:19.18] INFO: Running eval_interaction_utilities on 65 rows
Time to execute step 'joint_tour_scheduling': 0.29 s
Total time to execute iteration 1 with iteration value None: 0.29 s
[00:19.45] INFO: #run_model running step non_mandatory_tour_frequency
Running step 'non_mandatory_tour_frequency'
[00:19.48] DEBUG: @inject timetable
[00:19.55] INFO: Running non_mandatory_tour_frequency with 137 persons
[00:19.56] INFO: Running segment 'PTYPE_FULL' of size 48
[00:19.56] INFO: non_mandatory_tour_frequency.PTYPE_FULL.interaction_simulate Running adaptive_chunked_choosers with 48 choosers
[00:19.56] INFO: Running chunk 1 of 1 with 48 of 48 choosers
[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.60] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:19.61] INFO: Running eval_interaction_utilities on 4608 rows
[00:20.01] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/tracing.py:836: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  trace_results[slicer_column_name] = trace_ids[1]

[00:20.06] INFO: Running segment 'PTYPE_PART' of size 26
[00:20.06] INFO: non_mandatory_tour_frequency.PTYPE_PART.interaction_simulate Running adaptive_chunked_choosers with 26 choosers
[00:20.06] INFO: Running chunk 1 of 1 with 26 of 26 choosers
[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.08] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.09] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.10] INFO: Running eval_interaction_utilities on 2496 rows
[00:20.41] INFO: Running segment 'PTYPE_UNIVERSITY' of size 16
[00:20.42] INFO: non_mandatory_tour_frequency.PTYPE_UNIVERSITY.interaction_simulate Running adaptive_chunked_choosers with 16 choosers
[00:20.42] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.44] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.45] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.46] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.46] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.46] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.46] INFO: Running eval_interaction_utilities on 1536 rows
[00:20.82] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/tracing.py:836: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  trace_results[slicer_column_name] = trace_ids[1]

[00:20.86] INFO: Running segment 'PTYPE_NONWORK' of size 17
[00:20.87] INFO: non_mandatory_tour_frequency.PTYPE_NONWORK.interaction_simulate Running adaptive_chunked_choosers with 17 choosers
[00:20.87] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.90] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:20.91] INFO: Running eval_interaction_utilities on 1632 rows
[00:21.26] INFO: Running segment 'PTYPE_RETIRED' of size 12
[00:21.27] INFO: non_mandatory_tour_frequency.PTYPE_RETIRED.interaction_simulate Running adaptive_chunked_choosers with 12 choosers
[00:21.27] INFO: Running chunk 1 of 1 with 12 of 12 choosers
[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.30] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.31] INFO: Running eval_interaction_utilities on 1152 rows
[00:21.55] INFO: Running segment 'PTYPE_DRIVING' of size 1
[00:21.55] INFO: non_mandatory_tour_frequency.PTYPE_DRIVING.interaction_simulate Running adaptive_chunked_choosers with 1 choosers
[00:21.55] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.57] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.58] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.59] INFO: Running eval_interaction_utilities on 96 rows
[00:21.81] INFO: Running segment 'PTYPE_SCHOOL' of size 11
[00:21.82] INFO: non_mandatory_tour_frequency.PTYPE_SCHOOL.interaction_simulate Running adaptive_chunked_choosers with 11 choosers
[00:21.82] INFO: Running chunk 1 of 1 with 11 of 11 choosers
[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.84] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.85] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.86] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.86] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.86] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.86] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:21.86] INFO: Running eval_interaction_utilities on 1056 rows
[00:22.08] INFO: Running segment 'PTYPE_PRESCHOOL' of size 6
[00:22.08] INFO: non_mandatory_tour_frequency.PTYPE_PRESCHOOL.interaction_simulate Running adaptive_chunked_choosers with 6 choosers
[00:22.08] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[00:22.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.10] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.11] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/logit.py:330: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  alts_sample[c_chooser] = np.repeat(choosers[c].values, sample_size)

[00:22.12] INFO: Running eval_interaction_utilities on 576 rows
[00:22.23] INFO: extend_tour_counts increased tour count by 5 from 90 to 95
[00:22.29] INFO: non_mandatory_tour_frequency top 10 value counts:
0     102
16     17
1       8
8       8
4       7
9       4
17      3
20      3
2       3
12      2
Name: non_mandatory_tour_frequency, dtype: int64
Time to execute step 'non_mandatory_tour_frequency': 2.85 s
Total time to execute iteration 1 with iteration value None: 2.85 s
[00:22.38] INFO: #run_model running step non_mandatory_tour_destination
Running step 'non_mandatory_tour_destination'
[00:22.41] INFO: running non_mandatory_tour_destination.shopping.sample with 30 tours
[00:22.41] INFO: non_mandatory_tour_destination.shopping.sample.interaction_sample Running adaptive_chunked_choosers with 30 choosers
[00:22.41] INFO: Running chunk 1 of 1 with 30 of 30 choosers
[00:22.42] INFO: Running eval_interaction_utilities on 750 rows
[00:22.45] INFO: Running non_mandatory_tour_destination.shopping.logsums with 366 rows
[00:22.61] INFO: non_mandatory_tour_destination.shopping.logsums.compute_logsums Running adaptive_chunked_choosers with 366 choosers
[00:22.61] INFO: Running chunk 1 of 1 with 366 of 366 choosers
[00:23.04] INFO: Running tour_destination_simulate with 30 persons
[00:23.04] INFO: non_mandatory_tour_destination.shopping.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 30 choosers and 366 alternatives
[00:23.04] INFO: Running chunk 1 of 1 with 30 of 30 choosers
[00:23.05] INFO: Running eval_interaction_utilities on 366 rows
[00:23.08] INFO: running non_mandatory_tour_destination.othmaint.sample with 20 tours
[00:23.08] INFO: non_mandatory_tour_destination.othmaint.sample.interaction_sample Running adaptive_chunked_choosers with 20 choosers
[00:23.08] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:23.08] INFO: Running eval_interaction_utilities on 500 rows
[00:23.11] INFO: Running non_mandatory_tour_destination.othmaint.logsums with 286 rows
[00:23.27] INFO: non_mandatory_tour_destination.othmaint.logsums.compute_logsums Running adaptive_chunked_choosers with 286 choosers
[00:23.27] INFO: Running chunk 1 of 1 with 286 of 286 choosers
[00:23.68] INFO: Running tour_destination_simulate with 20 persons
[00:23.68] INFO: non_mandatory_tour_destination.othmaint.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 20 choosers and 286 alternatives
[00:23.68] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:23.68] INFO: Running eval_interaction_utilities on 286 rows
[00:23.71] INFO: running non_mandatory_tour_destination.othdiscr.sample with 20 tours
[00:23.71] INFO: non_mandatory_tour_destination.othdiscr.sample.interaction_sample Running adaptive_chunked_choosers with 20 choosers
[00:23.71] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:23.71] INFO: Running eval_interaction_utilities on 500 rows
[00:23.75] INFO: Running non_mandatory_tour_destination.othdiscr.logsums with 291 rows
[00:23.90] INFO: non_mandatory_tour_destination.othdiscr.logsums.compute_logsums Running adaptive_chunked_choosers with 291 choosers
[00:23.90] INFO: Running chunk 1 of 1 with 291 of 291 choosers
[00:24.36] INFO: Running tour_destination_simulate with 20 persons
[00:24.37] INFO: non_mandatory_tour_destination.othdiscr.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 20 choosers and 291 alternatives
[00:24.37] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:24.37] INFO: Running eval_interaction_utilities on 291 rows
[00:24.43] INFO: running non_mandatory_tour_destination.eatout.sample with 15 tours
[00:24.43] INFO: non_mandatory_tour_destination.eatout.sample.interaction_sample Running adaptive_chunked_choosers with 15 choosers
[00:24.43] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:24.44] INFO: Running eval_interaction_utilities on 375 rows
[00:24.49] INFO: Running non_mandatory_tour_destination.eatout.logsums with 203 rows
[00:24.65] INFO: non_mandatory_tour_destination.eatout.logsums.compute_logsums Running adaptive_chunked_choosers with 203 choosers
[00:24.65] INFO: Running chunk 1 of 1 with 203 of 203 choosers
[00:25.15] INFO: Running tour_destination_simulate with 15 persons
[00:25.15] INFO: non_mandatory_tour_destination.eatout.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 15 choosers and 203 alternatives
[00:25.15] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:25.16] INFO: Running eval_interaction_utilities on 203 rows
[00:25.20] INFO: running non_mandatory_tour_destination.social.sample with 7 tours
[00:25.20] INFO: non_mandatory_tour_destination.social.sample.interaction_sample Running adaptive_chunked_choosers with 7 choosers
[00:25.20] INFO: Running chunk 1 of 1 with 7 of 7 choosers
[00:25.20] INFO: Running eval_interaction_utilities on 175 rows
[00:25.24] INFO: Running non_mandatory_tour_destination.social.logsums with 97 rows
[00:25.39] INFO: non_mandatory_tour_destination.social.logsums.compute_logsums Running adaptive_chunked_choosers with 97 choosers
[00:25.39] INFO: Running chunk 1 of 1 with 97 of 97 choosers
[00:25.79] INFO: Running tour_destination_simulate with 7 persons
[00:25.79] INFO: non_mandatory_tour_destination.social.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 7 choosers and 97 alternatives
[00:25.79] INFO: Running chunk 1 of 1 with 7 of 7 choosers
[00:25.79] INFO: Running eval_interaction_utilities on 97 rows
[00:25.84] INFO: running non_mandatory_tour_destination.escort.sample with 3 tours
[00:25.84] INFO: non_mandatory_tour_destination.escort.sample.interaction_sample Running adaptive_chunked_choosers with 3 choosers
[00:25.84] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:25.84] INFO: Running eval_interaction_utilities on 75 rows
[00:25.88] INFO: Running non_mandatory_tour_destination.escort.logsums with 41 rows
[00:26.03] INFO: non_mandatory_tour_destination.escort.logsums.compute_logsums Running adaptive_chunked_choosers with 41 choosers
[00:26.03] INFO: Running chunk 1 of 1 with 41 of 41 choosers
[00:26.35] INFO: Running tour_destination_simulate with 3 persons
[00:26.35] INFO: non_mandatory_tour_destination.escort.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 3 choosers and 41 alternatives
[00:26.35] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:26.35] INFO: Running eval_interaction_utilities on 41 rows
Time to execute step 'non_mandatory_tour_destination': 3.99 s
Total time to execute iteration 1 with iteration value None: 3.99 s
[00:26.44] INFO: #run_model running step non_mandatory_tour_scheduling
Running step 'non_mandatory_tour_scheduling'
[00:26.45] DEBUG: @inject timetable
[00:26.50] INFO: Running non_mandatory_tour_scheduling with 95 tours
[00:26.50] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1 schedule_tours running 65 tour choices
[00:26.50] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1 Running adaptive_chunked_choosers with 65 choosers
[00:26.50] INFO: Running chunk 1 of 1 with 65 of 65 choosers
[00:26.50] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1 schedule_tours running 65 tour choices
[00:26.51] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_1.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 65 choosers and 9990 alternatives
[00:26.51] INFO: Running chunk 1 of 1 with 65 of 65 choosers
[00:26.52] INFO: Running eval_interaction_utilities on 9990 rows
[00:26.83] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2 schedule_tours running 23 tour choices
[00:26.83] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2 Running adaptive_chunked_choosers with 23 choosers
[00:26.83] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:26.83] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2 schedule_tours running 23 tour choices
[00:26.84] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_2.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 23 choosers and 1758 alternatives
[00:26.84] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:26.84] INFO: Running eval_interaction_utilities on 1758 rows
[00:27.01] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_3 schedule_tours running 6 tour choices
[00:27.01] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_3 Running adaptive_chunked_choosers with 6 choosers
[00:27.01] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[00:27.01] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_3 schedule_tours running 6 tour choices
[00:27.01] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_3.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 6 choosers and 200 alternatives
[00:27.01] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[00:27.01] INFO: Running eval_interaction_utilities on 200 rows
[00:27.17] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_4 schedule_tours running 1 tour choices
[00:27.17] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_4 Running adaptive_chunked_choosers with 1 choosers
[00:27.17] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:27.17] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_4 schedule_tours running 1 tour choices
[00:27.18] INFO: non_mandatory_tour_scheduling.vectorize_tour_scheduling.tour_4.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 18 alternatives
[00:27.18] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:27.18] INFO: Running eval_interaction_utilities on 18 rows
Time to execute step 'non_mandatory_tour_scheduling': 0.94 s
Total time to execute iteration 1 with iteration value None: 0.94 s
[00:27.46] INFO: #run_model running step tour_mode_choice_simulate
Running step 'tour_mode_choice_simulate'
[00:27.48] INFO: Running tour_mode_choice with 193 tours
[00:27.49] INFO: tour_types top 10 value counts:
work        69
shopping    31
school      26
othdiscr    21
othmaint    20
eatout      16
social       7
escort       3
Name: tour_type, dtype: int64
[00:27.49] INFO: tour_mode_choice_simulate tour_type 'eatout' (16 tours)
[00:27.67] INFO: tour_mode_choice.eatout.simple_simulate Running adaptive_chunked_choosers with 16 choosers
[00:27.67] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:28.15] INFO: tour_mode_choice_simulate eatout choices_df top 10 value counts:
WALK              12
WALK_LRF           3
DRIVEALONEFREE     1
Name: tour_mode, dtype: int64
[00:28.15] INFO: tour_mode_choice_simulate tour_type 'escort' (3 tours)
[00:28.30] INFO: tour_mode_choice.escort.simple_simulate Running adaptive_chunked_choosers with 3 choosers
[00:28.30] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:28.70] INFO: tour_mode_choice_simulate escort choices_df top 10 value counts:
SHARED2FREE    1
TNC_SINGLE     1
WALK_LOC       1
Name: tour_mode, dtype: int64
[00:28.70] INFO: tour_mode_choice_simulate tour_type 'othdiscr' (21 tours)
[00:28.86] INFO: tour_mode_choice.othdiscr.simple_simulate Running adaptive_chunked_choosers with 21 choosers
[00:28.86] INFO: Running chunk 1 of 1 with 21 of 21 choosers
[00:29.26] INFO: tour_mode_choice_simulate othdiscr choices_df top 10 value counts:
WALK              10
WALK_LRF           3
DRIVEALONEFREE     2
TNC_SINGLE         2
WALK_LOC           2
WALK_HVY           1
SHARED3FREE        1
Name: tour_mode, dtype: int64
[00:29.26] INFO: tour_mode_choice_simulate tour_type 'othmaint' (20 tours)
[00:29.42] INFO: tour_mode_choice.othmaint.simple_simulate Running adaptive_chunked_choosers with 20 choosers
[00:29.42] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:29.81] INFO: tour_mode_choice_simulate othmaint choices_df top 10 value counts:
WALK              9
BIKE              4
TNC_SINGLE        4
WALK_LOC          1
TAXI              1
DRIVEALONEFREE    1
Name: tour_mode, dtype: int64
[00:29.82] INFO: tour_mode_choice_simulate tour_type 'school' (17 tours)
[00:29.97] INFO: tour_mode_choice.school.simple_simulate Running adaptive_chunked_choosers with 17 choosers
[00:29.97] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:30.37] INFO: tour_mode_choice_simulate school choices_df top 10 value counts:
WALK           7
WALK_LOC       5
WALK_LRF       3
WALK_HVY       1
SHARED3FREE    1
Name: tour_mode, dtype: int64
[00:30.37] INFO: tour_mode_choice_simulate tour_type 'shopping' (31 tours)
[00:30.53] INFO: tour_mode_choice.shopping.simple_simulate Running adaptive_chunked_choosers with 31 choosers
[00:30.53] INFO: Running chunk 1 of 1 with 31 of 31 choosers
[00:30.94] INFO: tour_mode_choice_simulate shopping choices_df top 10 value counts:
WALK              13
WALK_LRF           7
WALK_LOC           5
TAXI               2
DRIVEALONEFREE     2
SHARED2FREE        1
TNC_SINGLE         1
Name: tour_mode, dtype: int64
[00:30.94] INFO: tour_mode_choice_simulate tour_type 'social' (7 tours)
[00:31.14] INFO: tour_mode_choice.social.simple_simulate Running adaptive_chunked_choosers with 7 choosers
[00:31.14] INFO: Running chunk 1 of 1 with 7 of 7 choosers
[00:31.56] INFO: tour_mode_choice_simulate social choices_df top 10 value counts:
WALK          2
WALK_LRF      2
TAXI          1
TNC_SINGLE    1
WALK_LOC      1
Name: tour_mode, dtype: int64
[00:31.56] INFO: tour_mode_choice_simulate tour_type 'univ' (9 tours)
[00:31.72] INFO: tour_mode_choice.univ.simple_simulate Running adaptive_chunked_choosers with 9 choosers
[00:31.72] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:32.13] INFO: tour_mode_choice_simulate univ choices_df top 10 value counts:
WALK              3
WALK_LRF          2
TNC_SHARED        1
DRIVEALONEFREE    1
TAXI              1
WALK_LOC          1
Name: tour_mode, dtype: int64
[00:32.13] INFO: tour_mode_choice_simulate tour_type 'work' (69 tours)
[00:32.30] INFO: tour_mode_choice.work.simple_simulate Running adaptive_chunked_choosers with 69 choosers
[00:32.30] INFO: Running chunk 1 of 1 with 69 of 69 choosers
[00:32.87] INFO: tour_mode_choice_simulate work choices_df top 10 value counts:
WALK              24
WALK_LOC          14
WALK_LRF          12
TNC_SINGLE         7
BIKE               4
DRIVEALONEFREE     3
WALK_HVY           3
SHARED3FREE        1
SHARED2FREE        1
Name: tour_mode, dtype: int64
[00:32.87] INFO: tour_mode_choice_simulate all tour type choices top 10 value counts:
WALK              80
WALK_LRF          32
WALK_LOC          30
TNC_SINGLE        16
DRIVEALONEFREE    10
BIKE               8
WALK_HVY           5
TAXI               5
SHARED2FREE        3
SHARED3FREE        3
Name: tour_mode, dtype: int64
Time to execute step 'tour_mode_choice_simulate': 5.41 s
Total time to execute iteration 1 with iteration value None: 5.41 s
[00:32.94] INFO: #run_model running step atwork_subtour_frequency
Running step 'atwork_subtour_frequency'
[00:32.97] INFO: Running atwork_subtour_frequency with 69 work tours
[00:33.00] INFO: atwork_subtour_frequency.simple_simulate Running adaptive_chunked_choosers with 69 choosers
[00:33.00] INFO: Running chunk 1 of 1 with 69 of 69 choosers
[00:33.09] WARNING: register tours: no rows with household_id in [982875].
[00:33.10] INFO: atwork_subtour_frequency top 10 value counts:
               133
no_subtours     60
eat              8
maint            1
Name: atwork_subtour_frequency, dtype: int64
Time to execute step 'atwork_subtour_frequency': 0.16 s
Total time to execute iteration 1 with iteration value None: 0.16 s
[00:33.17] INFO: #run_model running step atwork_subtour_destination
Running step 'atwork_subtour_destination'
[00:33.19] INFO: running atwork_subtour_destination.atwork.sample with 9 tours
[00:33.19] INFO: atwork_subtour_destination.atwork.sample.interaction_sample Running adaptive_chunked_choosers with 9 choosers
[00:33.19] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:33.20] INFO: Running eval_interaction_utilities on 225 rows
[00:33.24] INFO: Running atwork_subtour_destination.atwork.logsums with 124 rows
[00:33.39] INFO: atwork_subtour_destination.atwork.logsums.compute_logsums Running adaptive_chunked_choosers with 124 choosers
[00:33.39] INFO: Running chunk 1 of 1 with 124 of 124 choosers
[00:33.81] INFO: Running tour_destination_simulate with 9 persons
[00:33.81] INFO: atwork_subtour_destination.atwork.simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 9 choosers and 124 alternatives
[00:33.81] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:33.82] INFO: Running eval_interaction_utilities on 124 rows
[00:33.84] INFO: destination summary:
count     9.000000
mean     10.444444
std       7.333333
min       2.000000
25%       7.000000
50%       8.000000
75%      15.000000
max      25.000000
Name: destination, dtype: float64
Time to execute step 'atwork_subtour_destination': 0.68 s
Total time to execute iteration 1 with iteration value None: 0.68 s
[00:33.92] INFO: #run_model running step atwork_subtour_scheduling
Running step 'atwork_subtour_scheduling'
[00:33.94] INFO: Running atwork_subtour_scheduling with 9 tours
[00:33.97] INFO: atwork_subtour_scheduling.tour_1 schedule_tours running 9 tour choices
[00:33.97] INFO: atwork_subtour_scheduling.tour_1 Running adaptive_chunked_choosers with 9 choosers
[00:33.97] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:33.97] INFO: atwork_subtour_scheduling.tour_1 schedule_tours running 9 tour choices
[00:33.98] INFO: atwork_subtour_scheduling.tour_1.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 9 choosers and 651 alternatives
[00:33.98] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:33.99] INFO: Running eval_interaction_utilities on 651 rows
Time to execute step 'atwork_subtour_scheduling': 0.22 s
Total time to execute iteration 1 with iteration value None: 0.22 s
[00:34.21] INFO: #run_model running step atwork_subtour_mode_choice
Running step 'atwork_subtour_mode_choice'
[00:34.24] INFO: Running atwork_subtour_mode_choice with 9 subtours
[00:34.24] INFO: atwork_subtour_mode_choice tour_type top 10 value counts:
eat      8
maint    1
Name: tour_type, dtype: int64
[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.48] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.49] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[00:34.49] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/abm/models/util/mode.py:137: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  choosers[trace_column_names] = choosers.index

[00:34.49] INFO: atwork_subtour_mode_choice.simple_simulate Running adaptive_chunked_choosers with 9 choosers
[00:34.49] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:34.90] INFO: atwork_subtour_mode_choice choices top 10 value counts:
WALK    9
Name: tour_mode, dtype: int64
Time to execute step 'atwork_subtour_mode_choice': 0.70 s
Total time to execute iteration 1 with iteration value None: 0.70 s
[00:34.97] INFO: #run_model running step stop_frequency
Running step 'stop_frequency'
[00:35.09] INFO: stop_frequency segments top 10 value counts:
work        69
shopping    31
othdiscr    21
othmaint    20
school      17
eatout      16
atwork       9
univ         9
social       7
escort       3
Name: primary_purpose, dtype: int64
[00:35.09] INFO: stop_frequency running segment work with 69 chooser rows
[00:35.11] INFO: stop_frequency.work.simple_simulate Running adaptive_chunked_choosers with 69 choosers
[00:35.11] INFO: Running chunk 1 of 1 with 69 of 69 choosers
[00:35.22] INFO: stop_frequency running segment school with 17 chooser rows
[00:35.24] INFO: stop_frequency.school.simple_simulate Running adaptive_chunked_choosers with 17 choosers
[00:35.24] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:35.29] INFO: stop_frequency running segment univ with 9 chooser rows
[00:35.30] INFO: stop_frequency.univ.simple_simulate Running adaptive_chunked_choosers with 9 choosers
[00:35.30] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:35.35] INFO: stop_frequency running segment social with 7 chooser rows
[00:35.37] INFO: stop_frequency.social.simple_simulate Running adaptive_chunked_choosers with 7 choosers
[00:35.37] INFO: Running chunk 1 of 1 with 7 of 7 choosers
[00:35.44] INFO: stop_frequency running segment shopping with 31 chooser rows
[00:35.46] INFO: stop_frequency.shopping.simple_simulate Running adaptive_chunked_choosers with 31 choosers
[00:35.46] INFO: Running chunk 1 of 1 with 31 of 31 choosers
[00:35.52] INFO: stop_frequency running segment eatout with 16 chooser rows
[00:35.54] INFO: stop_frequency.eatout.simple_simulate Running adaptive_chunked_choosers with 16 choosers
[00:35.54] INFO: Running chunk 1 of 1 with 16 of 16 choosers
[00:35.63] INFO: stop_frequency running segment escort with 3 chooser rows
[00:35.65] INFO: stop_frequency.escort.simple_simulate Running adaptive_chunked_choosers with 3 choosers
[00:35.65] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:35.70] INFO: stop_frequency running segment othmaint with 20 chooser rows
[00:35.72] INFO: stop_frequency.othmaint.simple_simulate Running adaptive_chunked_choosers with 20 choosers
[00:35.72] INFO: Running chunk 1 of 1 with 20 of 20 choosers
[00:35.80] INFO: stop_frequency running segment othdiscr with 21 chooser rows
[00:35.82] INFO: stop_frequency.othdiscr.simple_simulate Running adaptive_chunked_choosers with 21 choosers
[00:35.82] INFO: Running chunk 1 of 1 with 21 of 21 choosers
[00:35.87] INFO: stop_frequency running segment atwork with 9 chooser rows
[00:35.89] INFO: stop_frequency.atwork.simple_simulate Running adaptive_chunked_choosers with 9 choosers
[00:35.89] INFO: Running chunk 1 of 1 with 9 of 9 choosers
[00:35.93] INFO: stop_frequency top 10 value counts:
0out_0in    157
0out_1in     14
1out_0in     10
0out_2in      8
1out_1in      4
3out_0in      3
1out_3in      2
3out_1in      1
2out_2in      1
2out_0in      1
dtype: int64
Time to execute step 'stop_frequency': 0.98 s
Total time to execute iteration 1 with iteration value None: 0.98 s
[00:36.04] INFO: #run_model running step trip_purpose
Running step 'trip_purpose'
[00:36.04] INFO: assign purpose to 202 last outbound trips
[00:36.04] INFO: assign purpose to 202 last inbound trips
[00:36.04] INFO: assign purpose to 78 intermediate trips
[00:36.07] INFO: trip_purpose Running adaptive_chunked_choosers with 78 choosers
[00:36.07] INFO: Running chunk 1 of 1 with 78 of 78 choosers
Time to execute step 'trip_purpose': 0.05 s
Total time to execute iteration 1 with iteration value None: 0.05 s
[00:36.15] INFO: #run_model running step trip_destination
Running step 'trip_destination'
[00:36.17] INFO: Running trip_destination with 482 trips
[00:36.22] INFO: Running trip_destination.trip_num_1 with 53 trips
[00:36.22] INFO: choose_trip_destination trip_destination.trip_num_1.atwork with 5 trips
[00:36.23] INFO: trip_destination.trip_num_1.atwork.sample.interaction_sample Running adaptive_chunked_choosers with 5 choosers
[00:36.23] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:36.23] INFO: Running eval_interaction_utilities on 125 rows
[00:36.25] INFO: Time to execute trip_destination.trip_num_1.atwork.trip_destination_sample : 0.028 seconds (0.0 minutes)
[00:36.25] INFO: Running trip_destination.trip_num_1.atwork.compute_logsums with 68 samples
[00:36.40] INFO: trip_destination.trip_num_1.atwork.compute_logsums.od Running adaptive_chunked_choosers with 68 choosers
[00:36.40] INFO: Running chunk 1 of 1 with 68 of 68 choosers
[00:36.86] INFO: trip_destination.trip_num_1.atwork.compute_logsums.dp Running adaptive_chunked_choosers with 68 choosers
[00:36.86] INFO: Running chunk 1 of 1 with 68 of 68 choosers
[00:37.23] INFO: Time to execute trip_destination.trip_num_1.atwork.compute_logsums : 0.974 seconds (0.0 minutes)
[00:37.26] INFO: Running trip_destination_simulate with 5 trips
[00:37.26] INFO: trip_destination.trip_num_1.atwork.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 5 choosers and 68 alternatives
[00:37.26] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:37.26] INFO: Running eval_interaction_utilities on 68 rows
[00:37.28] INFO: Time to execute trip_destination.trip_num_1.atwork.trip_destination_simulate : 0.052 seconds (0.0 minutes)
[00:37.28] INFO: choose_trip_destination trip_destination.trip_num_1.eatout with 1 trips
[00:37.28] INFO: trip_destination.trip_num_1.eatout.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:37.28] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:37.29] INFO: Running eval_interaction_utilities on 25 rows
[00:37.32] INFO: Time to execute trip_destination.trip_num_1.eatout.trip_destination_sample : 0.045 seconds (0.0 minutes)
[00:37.32] INFO: Running trip_destination.trip_num_1.eatout.compute_logsums with 15 samples
[00:37.49] INFO: trip_destination.trip_num_1.eatout.compute_logsums.od Running adaptive_chunked_choosers with 15 choosers
[00:37.49] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:37.94] INFO: trip_destination.trip_num_1.eatout.compute_logsums.dp Running adaptive_chunked_choosers with 15 choosers
[00:37.94] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:38.36] INFO: Time to execute trip_destination.trip_num_1.eatout.compute_logsums : 1.032 seconds (0.0 minutes)
[00:38.36] INFO: Running trip_destination_simulate with 1 trips
[00:38.36] INFO: trip_destination.trip_num_1.eatout.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 15 alternatives
[00:38.36] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:38.37] INFO: Running eval_interaction_utilities on 15 rows
[00:38.40] INFO: Time to execute trip_destination.trip_num_1.eatout.trip_destination_simulate : 0.045 seconds (0.0 minutes)
[00:38.40] INFO: choose_trip_destination trip_destination.trip_num_1.othdiscr with 1 trips
[00:38.41] INFO: trip_destination.trip_num_1.othdiscr.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:38.41] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:38.41] INFO: Running eval_interaction_utilities on 25 rows
[00:38.43] INFO: Time to execute trip_destination.trip_num_1.othdiscr.trip_destination_sample : 0.029 seconds (0.0 minutes)
[00:38.43] INFO: Running trip_destination.trip_num_1.othdiscr.compute_logsums with 15 samples
[00:38.57] INFO: trip_destination.trip_num_1.othdiscr.compute_logsums.od Running adaptive_chunked_choosers with 15 choosers
[00:38.57] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:38.94] INFO: trip_destination.trip_num_1.othdiscr.compute_logsums.dp Running adaptive_chunked_choosers with 15 choosers
[00:38.94] INFO: Running chunk 1 of 1 with 15 of 15 choosers
[00:39.23] INFO: Time to execute trip_destination.trip_num_1.othdiscr.compute_logsums : 0.796 seconds (0.0 minutes)
[00:39.23] INFO: Running trip_destination_simulate with 1 trips
[00:39.23] INFO: trip_destination.trip_num_1.othdiscr.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 15 alternatives
[00:39.23] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:39.23] INFO: Running eval_interaction_utilities on 15 rows
[00:39.25] INFO: Time to execute trip_destination.trip_num_1.othdiscr.trip_destination_simulate : 0.025 seconds (0.0 minutes)
[00:39.25] INFO: choose_trip_destination trip_destination.trip_num_1.othmaint with 3 trips
[00:39.26] INFO: trip_destination.trip_num_1.othmaint.sample.interaction_sample Running adaptive_chunked_choosers with 3 choosers
[00:39.26] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:39.26] INFO: Running eval_interaction_utilities on 75 rows
[00:39.28] INFO: Time to execute trip_destination.trip_num_1.othmaint.trip_destination_sample : 0.03 seconds (0.0 minutes)
[00:39.28] INFO: Running trip_destination.trip_num_1.othmaint.compute_logsums with 45 samples
[00:39.42] INFO: trip_destination.trip_num_1.othmaint.compute_logsums.od Running adaptive_chunked_choosers with 45 choosers
[00:39.42] INFO: Running chunk 1 of 1 with 45 of 45 choosers
[00:39.89] INFO: trip_destination.trip_num_1.othmaint.compute_logsums.dp Running adaptive_chunked_choosers with 45 choosers
[00:39.89] INFO: Running chunk 1 of 1 with 45 of 45 choosers
[00:40.25] INFO: Time to execute trip_destination.trip_num_1.othmaint.compute_logsums : 0.97 seconds (0.0 minutes)
[00:40.27] INFO: Running trip_destination_simulate with 3 trips
[00:40.27] INFO: trip_destination.trip_num_1.othmaint.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 3 choosers and 45 alternatives
[00:40.28] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:40.28] INFO: Running eval_interaction_utilities on 45 rows
[00:40.30] INFO: Time to execute trip_destination.trip_num_1.othmaint.trip_destination_simulate : 0.048 seconds (0.0 minutes)
[00:40.30] INFO: choose_trip_destination trip_destination.trip_num_1.school with 3 trips
[00:40.30] INFO: trip_destination.trip_num_1.school.sample.interaction_sample Running adaptive_chunked_choosers with 3 choosers
[00:40.30] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:40.31] INFO: Running eval_interaction_utilities on 75 rows
[00:40.33] INFO: Time to execute trip_destination.trip_num_1.school.trip_destination_sample : 0.028 seconds (0.0 minutes)
[00:40.33] INFO: Running trip_destination.trip_num_1.school.compute_logsums with 42 samples
[00:40.47] INFO: trip_destination.trip_num_1.school.compute_logsums.od Running adaptive_chunked_choosers with 42 choosers
[00:40.47] INFO: Running chunk 1 of 1 with 42 of 42 choosers
[00:40.94] INFO: trip_destination.trip_num_1.school.compute_logsums.dp Running adaptive_chunked_choosers with 42 choosers
[00:40.94] INFO: Running chunk 1 of 1 with 42 of 42 choosers
[00:41.29] INFO: Time to execute trip_destination.trip_num_1.school.compute_logsums : 0.967 seconds (0.0 minutes)
[00:41.31] INFO: Running trip_destination_simulate with 3 trips
[00:41.32] INFO: trip_destination.trip_num_1.school.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 3 choosers and 42 alternatives
[00:41.32] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:41.32] INFO: Running eval_interaction_utilities on 42 rows
[00:41.36] INFO: Time to execute trip_destination.trip_num_1.school.trip_destination_simulate : 0.071 seconds (0.0 minutes)
[00:41.37] INFO: choose_trip_destination trip_destination.trip_num_1.shopping with 10 trips
[00:41.38] INFO: trip_destination.trip_num_1.shopping.sample.interaction_sample Running adaptive_chunked_choosers with 10 choosers
[00:41.38] INFO: Running chunk 1 of 1 with 10 of 10 choosers
[00:41.38] INFO: Running eval_interaction_utilities on 250 rows
[00:41.41] INFO: Time to execute trip_destination.trip_num_1.shopping.trip_destination_sample : 0.038 seconds (0.0 minutes)
[00:41.41] INFO: Running trip_destination.trip_num_1.shopping.compute_logsums with 124 samples
[00:41.55] INFO: trip_destination.trip_num_1.shopping.compute_logsums.od Running adaptive_chunked_choosers with 124 choosers
[00:41.55] INFO: Running chunk 1 of 1 with 124 of 124 choosers
[00:42.03] INFO: trip_destination.trip_num_1.shopping.compute_logsums.dp Running adaptive_chunked_choosers with 124 choosers
[00:42.03] INFO: Running chunk 1 of 1 with 124 of 124 choosers
[00:42.40] INFO: Time to execute trip_destination.trip_num_1.shopping.compute_logsums : 0.991 seconds (0.0 minutes)
[00:42.42] INFO: Running trip_destination_simulate with 10 trips
[00:42.42] INFO: trip_destination.trip_num_1.shopping.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 10 choosers and 124 alternatives
[00:42.43] INFO: Running chunk 1 of 1 with 10 of 10 choosers
[00:42.43] INFO: Running eval_interaction_utilities on 124 rows
[00:42.45] INFO: Time to execute trip_destination.trip_num_1.shopping.trip_destination_simulate : 0.05 seconds (0.0 minutes)
[00:42.45] INFO: choose_trip_destination trip_destination.trip_num_1.social with 3 trips
[00:42.46] INFO: trip_destination.trip_num_1.social.sample.interaction_sample Running adaptive_chunked_choosers with 3 choosers
[00:42.46] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:42.46] INFO: Running eval_interaction_utilities on 75 rows
[00:42.48] INFO: Time to execute trip_destination.trip_num_1.social.trip_destination_sample : 0.029 seconds (0.0 minutes)
[00:42.48] INFO: Running trip_destination.trip_num_1.social.compute_logsums with 42 samples
[00:42.62] INFO: trip_destination.trip_num_1.social.compute_logsums.od Running adaptive_chunked_choosers with 42 choosers
[00:42.62] INFO: Running chunk 1 of 1 with 42 of 42 choosers
[00:43.09] INFO: trip_destination.trip_num_1.social.compute_logsums.dp Running adaptive_chunked_choosers with 42 choosers
[00:43.09] INFO: Running chunk 1 of 1 with 42 of 42 choosers
[00:43.45] INFO: Time to execute trip_destination.trip_num_1.social.compute_logsums : 0.969 seconds (0.0 minutes)
[00:43.47] INFO: Running trip_destination_simulate with 3 trips
[00:43.47] INFO: trip_destination.trip_num_1.social.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 3 choosers and 42 alternatives
[00:43.47] INFO: Running chunk 1 of 1 with 3 of 3 choosers
[00:43.47] INFO: Running eval_interaction_utilities on 42 rows
[00:43.52] INFO: Time to execute trip_destination.trip_num_1.social.trip_destination_simulate : 0.071 seconds (0.0 minutes)
[00:43.52] INFO: choose_trip_destination trip_destination.trip_num_1.univ with 5 trips
[00:43.53] INFO: trip_destination.trip_num_1.univ.sample.interaction_sample Running adaptive_chunked_choosers with 5 choosers
[00:43.53] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:43.53] INFO: Running eval_interaction_utilities on 125 rows
[00:43.56] INFO: Time to execute trip_destination.trip_num_1.univ.trip_destination_sample : 0.036 seconds (0.0 minutes)
[00:43.56] INFO: Running trip_destination.trip_num_1.univ.compute_logsums with 74 samples
[00:43.71] INFO: trip_destination.trip_num_1.univ.compute_logsums.od Running adaptive_chunked_choosers with 74 choosers
[00:43.71] INFO: Running chunk 1 of 1 with 74 of 74 choosers
[00:44.18] INFO: trip_destination.trip_num_1.univ.compute_logsums.dp Running adaptive_chunked_choosers with 74 choosers
[00:44.18] INFO: Running chunk 1 of 1 with 74 of 74 choosers
[00:44.54] INFO: Time to execute trip_destination.trip_num_1.univ.compute_logsums : 0.983 seconds (0.0 minutes)
[00:44.55] INFO: Running trip_destination_simulate with 5 trips
[00:44.55] INFO: trip_destination.trip_num_1.univ.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 5 choosers and 74 alternatives
[00:44.56] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:44.56] INFO: Running eval_interaction_utilities on 74 rows
[00:44.60] INFO: Time to execute trip_destination.trip_num_1.univ.trip_destination_simulate : 0.064 seconds (0.0 minutes)
[00:44.60] INFO: choose_trip_destination trip_destination.trip_num_1.work with 22 trips
[00:44.61] INFO: trip_destination.trip_num_1.work.sample.interaction_sample Running adaptive_chunked_choosers with 22 choosers
[00:44.61] INFO: Running chunk 1 of 1 with 22 of 22 choosers
[00:44.62] INFO: Running eval_interaction_utilities on 550 rows
[00:44.64] INFO: Time to execute trip_destination.trip_num_1.work.trip_destination_sample : 0.041 seconds (0.0 minutes)
[00:44.64] INFO: Running trip_destination.trip_num_1.work.compute_logsums with 287 samples
[00:44.80] INFO: trip_destination.trip_num_1.work.compute_logsums.od Running adaptive_chunked_choosers with 287 choosers
[00:44.80] INFO: Running chunk 1 of 1 with 287 of 287 choosers
[00:45.28] INFO: trip_destination.trip_num_1.work.compute_logsums.dp Running adaptive_chunked_choosers with 287 choosers
[00:45.28] INFO: Running chunk 1 of 1 with 287 of 287 choosers
[00:45.66] INFO: Time to execute trip_destination.trip_num_1.work.compute_logsums : 1.018 seconds (0.0 minutes)
[00:45.68] INFO: Running trip_destination_simulate with 22 trips
[00:45.68] INFO: trip_destination.trip_num_1.work.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 22 choosers and 287 alternatives
[00:45.68] INFO: Running chunk 1 of 1 with 22 of 22 choosers
[00:45.70] INFO: Running eval_interaction_utilities on 287 rows
[00:45.73] INFO: Time to execute trip_destination.trip_num_1.work.trip_destination_simulate : 0.071 seconds (0.0 minutes)
[00:45.76] INFO: Running trip_destination.trip_num_2 with 18 trips
[00:45.76] INFO: choose_trip_destination trip_destination.trip_num_2.atwork with 2 trips
[00:45.77] INFO: trip_destination.trip_num_2.atwork.sample.interaction_sample Running adaptive_chunked_choosers with 2 choosers
[00:45.77] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:45.78] INFO: Running eval_interaction_utilities on 50 rows
[00:45.80] INFO: Time to execute trip_destination.trip_num_2.atwork.trip_destination_sample : 0.033 seconds (0.0 minutes)
[00:45.80] INFO: Running trip_destination.trip_num_2.atwork.compute_logsums with 23 samples
[00:45.95] INFO: trip_destination.trip_num_2.atwork.compute_logsums.od Running adaptive_chunked_choosers with 23 choosers
[00:45.95] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:46.31] INFO: trip_destination.trip_num_2.atwork.compute_logsums.dp Running adaptive_chunked_choosers with 23 choosers
[00:46.31] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:46.60] INFO: Time to execute trip_destination.trip_num_2.atwork.compute_logsums : 0.806 seconds (0.0 minutes)
[00:46.61] INFO: Running trip_destination_simulate with 2 trips
[00:46.61] INFO: trip_destination.trip_num_2.atwork.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 23 alternatives
[00:46.61] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:46.61] INFO: Running eval_interaction_utilities on 23 rows
[00:46.62] INFO: Time to execute trip_destination.trip_num_2.atwork.trip_destination_simulate : 0.021 seconds (0.0 minutes)
[00:46.63] INFO: choose_trip_destination trip_destination.trip_num_2.othmaint with 2 trips
[00:46.63] INFO: trip_destination.trip_num_2.othmaint.sample.interaction_sample Running adaptive_chunked_choosers with 2 choosers
[00:46.63] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:46.64] INFO: Running eval_interaction_utilities on 50 rows
[00:46.65] INFO: Time to execute trip_destination.trip_num_2.othmaint.trip_destination_sample : 0.029 seconds (0.0 minutes)
[00:46.65] INFO: Running trip_destination.trip_num_2.othmaint.compute_logsums with 23 samples
[00:46.80] INFO: trip_destination.trip_num_2.othmaint.compute_logsums.od Running adaptive_chunked_choosers with 23 choosers
[00:46.80] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:47.16] INFO: trip_destination.trip_num_2.othmaint.compute_logsums.dp Running adaptive_chunked_choosers with 23 choosers
[00:47.16] INFO: Running chunk 1 of 1 with 23 of 23 choosers
[00:47.46] INFO: Time to execute trip_destination.trip_num_2.othmaint.compute_logsums : 0.804 seconds (0.0 minutes)
[00:47.46] INFO: Running trip_destination_simulate with 2 trips
[00:47.46] INFO: trip_destination.trip_num_2.othmaint.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 23 alternatives
[00:47.46] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:47.47] INFO: Running eval_interaction_utilities on 23 rows
[00:47.48] INFO: Time to execute trip_destination.trip_num_2.othmaint.trip_destination_simulate : 0.025 seconds (0.0 minutes)
[00:47.48] INFO: choose_trip_destination trip_destination.trip_num_2.shopping with 5 trips
[00:47.49] INFO: trip_destination.trip_num_2.shopping.sample.interaction_sample Running adaptive_chunked_choosers with 5 choosers
[00:47.49] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:47.49] INFO: Running eval_interaction_utilities on 125 rows
[00:47.55] INFO: Time to execute trip_destination.trip_num_2.shopping.trip_destination_sample : 0.067 seconds (0.0 minutes)
[00:47.55] INFO: Running trip_destination.trip_num_2.shopping.compute_logsums with 69 samples
[00:47.72] INFO: trip_destination.trip_num_2.shopping.compute_logsums.od Running adaptive_chunked_choosers with 69 choosers
[00:47.72] INFO: Running chunk 1 of 1 with 69 of 69 choosers
[00:48.22] INFO: trip_destination.trip_num_2.shopping.compute_logsums.dp Running adaptive_chunked_choosers with 69 choosers
[00:48.22] INFO: Running chunk 1 of 1 with 69 of 69 choosers
[00:48.58] INFO: Time to execute trip_destination.trip_num_2.shopping.compute_logsums : 1.03 seconds (0.0 minutes)
[00:48.60] INFO: Running trip_destination_simulate with 5 trips
[00:48.60] INFO: trip_destination.trip_num_2.shopping.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 5 choosers and 69 alternatives
[00:48.60] INFO: Running chunk 1 of 1 with 5 of 5 choosers
[00:48.61] INFO: Running eval_interaction_utilities on 69 rows
[00:48.65] INFO: Time to execute trip_destination.trip_num_2.shopping.trip_destination_simulate : 0.074 seconds (0.0 minutes)
[00:48.65] INFO: choose_trip_destination trip_destination.trip_num_2.social with 1 trips
[00:48.66] INFO: trip_destination.trip_num_2.social.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:48.66] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:48.67] INFO: Running eval_interaction_utilities on 25 rows
[00:48.69] INFO: Time to execute trip_destination.trip_num_2.social.trip_destination_sample : 0.037 seconds (0.0 minutes)
[00:48.69] INFO: Running trip_destination.trip_num_2.social.compute_logsums with 10 samples
[00:48.84] INFO: trip_destination.trip_num_2.social.compute_logsums.od Running adaptive_chunked_choosers with 10 choosers
[00:48.84] INFO: Running chunk 1 of 1 with 10 of 10 choosers
[00:49.20] INFO: trip_destination.trip_num_2.social.compute_logsums.dp Running adaptive_chunked_choosers with 10 choosers
[00:49.20] INFO: Running chunk 1 of 1 with 10 of 10 choosers
[00:49.50] INFO: Time to execute trip_destination.trip_num_2.social.compute_logsums : 0.804 seconds (0.0 minutes)
[00:49.50] INFO: Running trip_destination_simulate with 1 trips
[00:49.50] INFO: trip_destination.trip_num_2.social.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 10 alternatives
[00:49.50] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:49.50] INFO: Running eval_interaction_utilities on 10 rows
[00:49.52] INFO: Time to execute trip_destination.trip_num_2.social.trip_destination_simulate : 0.024 seconds (0.0 minutes)
[00:49.52] INFO: choose_trip_destination trip_destination.trip_num_2.univ with 2 trips
[00:49.53] INFO: trip_destination.trip_num_2.univ.sample.interaction_sample Running adaptive_chunked_choosers with 2 choosers
[00:49.53] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:49.53] INFO: Running eval_interaction_utilities on 50 rows
[00:49.55] INFO: Time to execute trip_destination.trip_num_2.univ.trip_destination_sample : 0.031 seconds (0.0 minutes)
[00:49.55] INFO: Running trip_destination.trip_num_2.univ.compute_logsums with 27 samples
[00:49.70] INFO: trip_destination.trip_num_2.univ.compute_logsums.od Running adaptive_chunked_choosers with 27 choosers
[00:49.70] INFO: Running chunk 1 of 1 with 27 of 27 choosers
[00:50.06] INFO: trip_destination.trip_num_2.univ.compute_logsums.dp Running adaptive_chunked_choosers with 27 choosers
[00:50.06] INFO: Running chunk 1 of 1 with 27 of 27 choosers
[00:50.35] INFO: Time to execute trip_destination.trip_num_2.univ.compute_logsums : 0.796 seconds (0.0 minutes)
[00:50.35] INFO: Running trip_destination_simulate with 2 trips
[00:50.35] INFO: trip_destination.trip_num_2.univ.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 27 alternatives
[00:50.35] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:50.36] INFO: Running eval_interaction_utilities on 27 rows
[00:50.37] INFO: Time to execute trip_destination.trip_num_2.univ.trip_destination_simulate : 0.023 seconds (0.0 minutes)
[00:50.37] INFO: choose_trip_destination trip_destination.trip_num_2.work with 6 trips
[00:50.38] INFO: trip_destination.trip_num_2.work.sample.interaction_sample Running adaptive_chunked_choosers with 6 choosers
[00:50.38] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[00:50.38] INFO: Running eval_interaction_utilities on 150 rows
[00:50.40] INFO: Time to execute trip_destination.trip_num_2.work.trip_destination_sample : 0.033 seconds (0.0 minutes)
[00:50.40] INFO: Running trip_destination.trip_num_2.work.compute_logsums with 81 samples
[00:50.55] INFO: trip_destination.trip_num_2.work.compute_logsums.od Running adaptive_chunked_choosers with 81 choosers
[00:50.55] INFO: Running chunk 1 of 1 with 81 of 81 choosers
[00:51.05] INFO: trip_destination.trip_num_2.work.compute_logsums.dp Running adaptive_chunked_choosers with 81 choosers
[00:51.05] INFO: Running chunk 1 of 1 with 81 of 81 choosers
[00:51.42] INFO: Time to execute trip_destination.trip_num_2.work.compute_logsums : 1.015 seconds (0.0 minutes)
[00:51.44] INFO: Running trip_destination_simulate with 6 trips
[00:51.44] INFO: trip_destination.trip_num_2.work.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 6 choosers and 81 alternatives
[00:51.44] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[00:51.45] INFO: Running eval_interaction_utilities on 81 rows
[00:51.49] INFO: Time to execute trip_destination.trip_num_2.work.trip_destination_simulate : 0.074 seconds (0.0 minutes)
[00:51.52] INFO: Running trip_destination.trip_num_3 with 7 trips
[00:51.53] INFO: choose_trip_destination trip_destination.trip_num_3.atwork with 2 trips
[00:51.53] INFO: trip_destination.trip_num_3.atwork.sample.interaction_sample Running adaptive_chunked_choosers with 2 choosers
[00:51.53] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:51.54] INFO: Running eval_interaction_utilities on 50 rows
[00:51.56] INFO: Time to execute trip_destination.trip_num_3.atwork.trip_destination_sample : 0.032 seconds (0.0 minutes)
[00:51.56] INFO: Running trip_destination.trip_num_3.atwork.compute_logsums with 29 samples
[00:51.71] INFO: trip_destination.trip_num_3.atwork.compute_logsums.od Running adaptive_chunked_choosers with 29 choosers
[00:51.71] INFO: Running chunk 1 of 1 with 29 of 29 choosers
[00:52.07] INFO: trip_destination.trip_num_3.atwork.compute_logsums.dp Running adaptive_chunked_choosers with 29 choosers
[00:52.07] INFO: Running chunk 1 of 1 with 29 of 29 choosers
[00:52.42] INFO: Time to execute trip_destination.trip_num_3.atwork.compute_logsums : 0.858 seconds (0.0 minutes)
[00:52.42] INFO: Running trip_destination_simulate with 2 trips
[00:52.42] INFO: trip_destination.trip_num_3.atwork.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 29 alternatives
[00:52.42] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:52.42] INFO: Running eval_interaction_utilities on 29 rows
[00:52.44] INFO: Time to execute trip_destination.trip_num_3.atwork.trip_destination_simulate : 0.025 seconds (0.0 minutes)
[00:52.44] INFO: choose_trip_destination trip_destination.trip_num_3.othmaint with 1 trips
[00:52.45] INFO: trip_destination.trip_num_3.othmaint.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:52.45] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:52.45] INFO: Running eval_interaction_utilities on 25 rows
[00:52.47] INFO: Time to execute trip_destination.trip_num_3.othmaint.trip_destination_sample : 0.033 seconds (0.0 minutes)
[00:52.47] INFO: Running trip_destination.trip_num_3.othmaint.compute_logsums with 12 samples
[00:52.62] INFO: trip_destination.trip_num_3.othmaint.compute_logsums.od Running adaptive_chunked_choosers with 12 choosers
[00:52.62] INFO: Running chunk 1 of 1 with 12 of 12 choosers
[00:52.99] INFO: trip_destination.trip_num_3.othmaint.compute_logsums.dp Running adaptive_chunked_choosers with 12 choosers
[00:52.99] INFO: Running chunk 1 of 1 with 12 of 12 choosers
[00:53.29] INFO: Time to execute trip_destination.trip_num_3.othmaint.compute_logsums : 0.815 seconds (0.0 minutes)
[00:53.29] INFO: Running trip_destination_simulate with 1 trips
[00:53.29] INFO: trip_destination.trip_num_3.othmaint.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 12 alternatives
[00:53.29] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:53.30] INFO: Running eval_interaction_utilities on 12 rows
[00:53.31] INFO: Time to execute trip_destination.trip_num_3.othmaint.trip_destination_simulate : 0.024 seconds (0.0 minutes)
[00:53.31] INFO: choose_trip_destination trip_destination.trip_num_3.social with 1 trips
[00:53.32] INFO: trip_destination.trip_num_3.social.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:53.32] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:53.32] INFO: Running eval_interaction_utilities on 25 rows
[00:53.34] INFO: Time to execute trip_destination.trip_num_3.social.trip_destination_sample : 0.033 seconds (0.0 minutes)
[00:53.34] INFO: Running trip_destination.trip_num_3.social.compute_logsums with 17 samples
[00:53.49] INFO: trip_destination.trip_num_3.social.compute_logsums.od Running adaptive_chunked_choosers with 17 choosers
[00:53.50] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:53.86] INFO: trip_destination.trip_num_3.social.compute_logsums.dp Running adaptive_chunked_choosers with 17 choosers
[00:53.86] INFO: Running chunk 1 of 1 with 17 of 17 choosers
[00:54.18] INFO: Time to execute trip_destination.trip_num_3.social.compute_logsums : 0.837 seconds (0.0 minutes)
[00:54.19] INFO: Running trip_destination_simulate with 1 trips
[00:54.19] INFO: trip_destination.trip_num_3.social.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 17 alternatives
[00:54.19] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:54.19] INFO: Running eval_interaction_utilities on 17 rows
[00:54.21] INFO: Time to execute trip_destination.trip_num_3.social.trip_destination_simulate : 0.025 seconds (0.0 minutes)
[00:54.21] INFO: choose_trip_destination trip_destination.trip_num_3.univ with 1 trips
[00:54.21] INFO: trip_destination.trip_num_3.univ.sample.interaction_sample Running adaptive_chunked_choosers with 1 choosers
[00:54.21] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:54.22] INFO: Running eval_interaction_utilities on 25 rows
[00:54.24] INFO: Time to execute trip_destination.trip_num_3.univ.trip_destination_sample : 0.032 seconds (0.0 minutes)
[00:54.24] INFO: Running trip_destination.trip_num_3.univ.compute_logsums with 14 samples
[00:54.39] INFO: trip_destination.trip_num_3.univ.compute_logsums.od Running adaptive_chunked_choosers with 14 choosers
[00:54.39] INFO: Running chunk 1 of 1 with 14 of 14 choosers
[00:54.78] INFO: trip_destination.trip_num_3.univ.compute_logsums.dp Running adaptive_chunked_choosers with 14 choosers
[00:54.78] INFO: Running chunk 1 of 1 with 14 of 14 choosers
[00:55.09] INFO: Time to execute trip_destination.trip_num_3.univ.compute_logsums : 0.856 seconds (0.0 minutes)
[00:55.10] INFO: Running trip_destination_simulate with 1 trips
[00:55.10] INFO: trip_destination.trip_num_3.univ.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 1 choosers and 14 alternatives
[00:55.10] INFO: Running chunk 1 of 1 with 1 of 1 choosers
[00:55.10] INFO: Running eval_interaction_utilities on 14 rows
[00:55.12] INFO: Time to execute trip_destination.trip_num_3.univ.trip_destination_simulate : 0.024 seconds (0.0 minutes)
[00:55.12] INFO: choose_trip_destination trip_destination.trip_num_3.work with 2 trips
[00:55.12] INFO: trip_destination.trip_num_3.work.sample.interaction_sample Running adaptive_chunked_choosers with 2 choosers
[00:55.12] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:55.13] INFO: Running eval_interaction_utilities on 50 rows
[00:55.15] INFO: Time to execute trip_destination.trip_num_3.work.trip_destination_sample : 0.032 seconds (0.0 minutes)
[00:55.15] INFO: Running trip_destination.trip_num_3.work.compute_logsums with 28 samples
[00:55.29] INFO: trip_destination.trip_num_3.work.compute_logsums.od Running adaptive_chunked_choosers with 28 choosers
[00:55.29] INFO: Running chunk 1 of 1 with 28 of 28 choosers
[00:55.66] INFO: trip_destination.trip_num_3.work.compute_logsums.dp Running adaptive_chunked_choosers with 28 choosers
[00:55.66] INFO: Running chunk 1 of 1 with 28 of 28 choosers
[00:55.94] INFO: Time to execute trip_destination.trip_num_3.work.compute_logsums : 0.794 seconds (0.0 minutes)
[00:55.95] INFO: Running trip_destination_simulate with 2 trips
[00:55.95] INFO: trip_destination.trip_num_3.work.trip_dest_simulate.interaction_sample_simulate Running adaptive_chunked_choosers_and_alts with 2 choosers and 28 alternatives
[00:55.95] INFO: Running chunk 1 of 1 with 2 of 2 choosers
[00:55.95] INFO: Running eval_interaction_utilities on 28 rows
[00:55.97] INFO: Time to execute trip_destination.trip_num_3.work.trip_destination_simulate : 0.026 seconds (0.0 minutes)
Time to execute step 'trip_destination': 19.83 s
Total time to execute iteration 1 with iteration value None: 19.83 s
[00:56.05] INFO: #run_model running step trip_purpose_and_destination
Running step 'trip_purpose_and_destination'
[00:56.07] INFO: trip_purpose_and_destination - no failed trips from prior model run.
Time to execute step 'trip_purpose_and_destination': 0.02 s
Total time to execute iteration 1 with iteration value None: 0.02 s
[00:56.15] INFO: #run_model running step trip_scheduling
Running step 'trip_scheduling'
[00:56.17] INFO: trip_scheduling Running chunk 1 of 1 with 202 of 202 choosers
[00:56.17] INFO: trip_scheduling.i1 scheduling 482 trips within chunk 1
[00:56.25] INFO: trip_scheduling.i1 6 failed
[00:56.25] INFO: trip_scheduling.i2 scheduling 18 trips within chunk 1
[00:56.33] INFO: trip_scheduling.i2 7 failed
[00:56.33] INFO: trip_scheduling.i3 scheduling 11 trips within chunk 1
[00:56.41] INFO: trip_scheduling.i3 7 failed
[00:56.41] INFO: trip_scheduling.i4 scheduling 11 trips within chunk 1
[00:56.49] INFO: trip_scheduling.i4 7 failed
[00:56.49] INFO: trip_scheduling.i5 scheduling 11 trips within chunk 1
[00:56.57] INFO: trip_scheduling.i5 7 failed
[00:56.57] INFO: trip_scheduling.i6 scheduling 11 trips within chunk 1
[00:56.65] INFO: trip_scheduling.i6 7 failed
[00:56.65] INFO: trip_scheduling.i7 scheduling 11 trips within chunk 1
[00:56.73] INFO: trip_scheduling.i7 7 failed
[00:56.73] INFO: trip_scheduling.i8 scheduling 11 trips within chunk 1
[00:56.81] INFO: trip_scheduling.i8 7 failed
[00:56.81] INFO: trip_scheduling.i9 scheduling 11 trips within chunk 1
[00:56.88] INFO: trip_scheduling.i9 7 failed
[00:56.89] INFO: trip_scheduling.i10 scheduling 11 trips within chunk 1
[00:56.96] INFO: trip_scheduling.i10 7 failed
[00:56.96] INFO: trip_scheduling.i11 scheduling 11 trips within chunk 1
[00:57.04] INFO: trip_scheduling.i11 7 failed
[00:57.04] INFO: trip_scheduling.i12 scheduling 11 trips within chunk 1
[00:57.12] INFO: trip_scheduling.i12 7 failed
[00:57.12] INFO: trip_scheduling.i13 scheduling 11 trips within chunk 1
[00:57.19] INFO: trip_scheduling.i13 7 failed
[00:57.20] INFO: trip_scheduling.i14 scheduling 11 trips within chunk 1
[00:57.27] INFO: trip_scheduling.i14 7 failed
[00:57.27] INFO: trip_scheduling.i15 scheduling 11 trips within chunk 1
[00:57.35] INFO: trip_scheduling.i15 7 failed
[00:57.35] INFO: trip_scheduling.i16 scheduling 11 trips within chunk 1
[00:57.43] INFO: trip_scheduling.i16 7 failed
[00:57.43] INFO: trip_scheduling.i17 scheduling 11 trips within chunk 1
[00:57.51] INFO: trip_scheduling.i17 7 failed
[00:57.51] INFO: trip_scheduling.i18 scheduling 11 trips within chunk 1
[00:57.58] INFO: trip_scheduling.i18 7 failed
[00:57.58] INFO: trip_scheduling.i19 scheduling 11 trips within chunk 1
[00:57.66] INFO: trip_scheduling.i19 7 failed
[00:57.66] INFO: trip_scheduling.i20 scheduling 11 trips within chunk 1
[00:57.73] INFO: trip_scheduling.i20 7 failed
[00:57.73] INFO: trip_scheduling.i21 scheduling 11 trips within chunk 1
[00:57.81] INFO: trip_scheduling.i21 7 failed
[00:57.81] INFO: trip_scheduling.i22 scheduling 11 trips within chunk 1
[00:57.88] INFO: trip_scheduling.i22 7 failed
[00:57.88] INFO: trip_scheduling.i23 scheduling 11 trips within chunk 1
[00:57.96] INFO: trip_scheduling.i23 7 failed
[00:57.96] INFO: trip_scheduling.i24 scheduling 11 trips within chunk 1
[00:58.04] INFO: trip_scheduling.i24 7 failed
[00:58.04] INFO: trip_scheduling.i25 scheduling 11 trips within chunk 1
[00:58.11] INFO: trip_scheduling.i25 7 failed
[00:58.12] INFO: trip_scheduling.i26 scheduling 11 trips within chunk 1
[00:58.19] INFO: trip_scheduling.i26 7 failed
[00:58.19] INFO: trip_scheduling.i27 scheduling 11 trips within chunk 1
[00:58.26] INFO: trip_scheduling.i27 7 failed
[00:58.26] INFO: trip_scheduling.i28 scheduling 11 trips within chunk 1
[00:58.34] INFO: trip_scheduling.i28 7 failed
[00:58.34] INFO: trip_scheduling.i29 scheduling 11 trips within chunk 1
[00:58.41] INFO: trip_scheduling.i29 7 failed
[00:58.42] INFO: trip_scheduling.i30 scheduling 11 trips within chunk 1
[00:58.49] INFO: trip_scheduling.i30 7 failed
[00:58.49] INFO: trip_scheduling.i31 scheduling 11 trips within chunk 1
[00:58.57] INFO: trip_scheduling.i31 7 failed
[00:58.57] INFO: trip_scheduling.i32 scheduling 11 trips within chunk 1
[00:58.64] INFO: trip_scheduling.i32 7 failed
[00:58.64] INFO: trip_scheduling.i33 scheduling 11 trips within chunk 1
[00:58.72] INFO: trip_scheduling.i33 7 failed
[00:58.72] INFO: trip_scheduling.i34 scheduling 11 trips within chunk 1
[00:58.79] INFO: trip_scheduling.i34 7 failed
[00:58.79] INFO: trip_scheduling.i35 scheduling 11 trips within chunk 1
[00:58.87] INFO: trip_scheduling.i35 7 failed
[00:58.87] INFO: trip_scheduling.i36 scheduling 11 trips within chunk 1
[00:58.94] INFO: trip_scheduling.i36 7 failed
[00:58.94] INFO: trip_scheduling.i37 scheduling 11 trips within chunk 1
[00:59.02] INFO: trip_scheduling.i37 7 failed
[00:59.02] INFO: trip_scheduling.i38 scheduling 11 trips within chunk 1
[00:59.10] INFO: trip_scheduling.i38 7 failed
[00:59.10] INFO: trip_scheduling.i39 scheduling 11 trips within chunk 1
[00:59.18] INFO: trip_scheduling.i39 7 failed
[00:59.18] INFO: trip_scheduling.i40 scheduling 11 trips within chunk 1
[00:59.25] INFO: trip_scheduling.i40 7 failed
[00:59.25] INFO: trip_scheduling.i41 scheduling 11 trips within chunk 1
[00:59.33] INFO: trip_scheduling.i41 7 failed
[00:59.33] INFO: trip_scheduling.i42 scheduling 11 trips within chunk 1
[00:59.40] INFO: trip_scheduling.i42 7 failed
[00:59.40] INFO: trip_scheduling.i43 scheduling 11 trips within chunk 1
[00:59.48] INFO: trip_scheduling.i43 7 failed
[00:59.48] INFO: trip_scheduling.i44 scheduling 11 trips within chunk 1
[00:59.56] INFO: trip_scheduling.i44 7 failed
[00:59.56] INFO: trip_scheduling.i45 scheduling 11 trips within chunk 1
[00:59.65] INFO: trip_scheduling.i45 7 failed
[00:59.65] INFO: trip_scheduling.i46 scheduling 11 trips within chunk 1
[00:59.74] INFO: trip_scheduling.i46 7 failed
[00:59.74] INFO: trip_scheduling.i47 scheduling 11 trips within chunk 1
[00:59.81] INFO: trip_scheduling.i47 7 failed
[00:59.81] INFO: trip_scheduling.i48 scheduling 11 trips within chunk 1
[00:59.89] INFO: trip_scheduling.i48 7 failed
[00:59.89] INFO: trip_scheduling.i49 scheduling 11 trips within chunk 1
[00:59.97] INFO: trip_scheduling.i49 7 failed
[00:59.97] INFO: trip_scheduling.i50 scheduling 11 trips within chunk 1
[01:00.04] INFO: trip_scheduling.i50 7 failed
[01:00.05] INFO: trip_scheduling.i51 scheduling 11 trips within chunk 1
[01:00.12] INFO: trip_scheduling.i51 7 failed
[01:00.12] INFO: trip_scheduling.i52 scheduling 11 trips within chunk 1
[01:00.19] INFO: trip_scheduling.i52 7 failed
[01:00.20] INFO: trip_scheduling.i53 scheduling 11 trips within chunk 1
[01:00.27] INFO: trip_scheduling.i53 7 failed
[01:00.27] INFO: trip_scheduling.i54 scheduling 11 trips within chunk 1
[01:00.35] INFO: trip_scheduling.i54 7 failed
[01:00.35] INFO: trip_scheduling.i55 scheduling 11 trips within chunk 1
[01:00.43] INFO: trip_scheduling.i55 7 failed
[01:00.43] INFO: trip_scheduling.i56 scheduling 11 trips within chunk 1
[01:00.50] INFO: trip_scheduling.i56 7 failed
[01:00.51] INFO: trip_scheduling.i57 scheduling 11 trips within chunk 1
[01:00.58] INFO: trip_scheduling.i57 7 failed
[01:00.58] INFO: trip_scheduling.i58 scheduling 11 trips within chunk 1
[01:00.65] INFO: trip_scheduling.i58 7 failed
[01:00.65] INFO: trip_scheduling.i59 scheduling 11 trips within chunk 1
[01:00.73] INFO: trip_scheduling.i59 7 failed
[01:00.73] INFO: trip_scheduling.i60 scheduling 11 trips within chunk 1
[01:00.80] INFO: trip_scheduling.i60 7 failed
[01:00.80] INFO: trip_scheduling.i61 scheduling 11 trips within chunk 1
[01:00.88] INFO: trip_scheduling.i61 7 failed
[01:00.88] INFO: trip_scheduling.i62 scheduling 11 trips within chunk 1
[01:00.95] INFO: trip_scheduling.i62 7 failed
[01:00.96] INFO: trip_scheduling.i63 scheduling 11 trips within chunk 1
[01:01.03] INFO: trip_scheduling.i63 7 failed
[01:01.03] INFO: trip_scheduling.i64 scheduling 11 trips within chunk 1
[01:01.11] INFO: trip_scheduling.i64 7 failed
[01:01.11] INFO: trip_scheduling.i65 scheduling 11 trips within chunk 1
[01:01.18] INFO: trip_scheduling.i65 7 failed
[01:01.18] INFO: trip_scheduling.i66 scheduling 11 trips within chunk 1
[01:01.26] INFO: trip_scheduling.i66 7 failed
[01:01.26] INFO: trip_scheduling.i67 scheduling 11 trips within chunk 1
[01:01.33] INFO: trip_scheduling.i67 7 failed
[01:01.34] INFO: trip_scheduling.i68 scheduling 11 trips within chunk 1
[01:01.41] INFO: trip_scheduling.i68 7 failed
[01:01.41] INFO: trip_scheduling.i69 scheduling 11 trips within chunk 1
[01:01.49] INFO: trip_scheduling.i69 7 failed
[01:01.49] INFO: trip_scheduling.i70 scheduling 11 trips within chunk 1
[01:01.56] INFO: trip_scheduling.i70 7 failed
[01:01.56] INFO: trip_scheduling.i71 scheduling 11 trips within chunk 1
[01:01.64] INFO: trip_scheduling.i71 7 failed
[01:01.64] INFO: trip_scheduling.i72 scheduling 11 trips within chunk 1
[01:01.71] INFO: trip_scheduling.i72 7 failed
[01:01.71] INFO: trip_scheduling.i73 scheduling 11 trips within chunk 1
[01:01.78] INFO: trip_scheduling.i73 7 failed
[01:01.79] INFO: trip_scheduling.i74 scheduling 11 trips within chunk 1
[01:01.86] INFO: trip_scheduling.i74 7 failed
[01:01.86] INFO: trip_scheduling.i75 scheduling 11 trips within chunk 1
[01:01.93] INFO: trip_scheduling.i75 7 failed
[01:01.93] INFO: trip_scheduling.i76 scheduling 11 trips within chunk 1
[01:02.01] INFO: trip_scheduling.i76 7 failed
[01:02.01] INFO: trip_scheduling.i77 scheduling 11 trips within chunk 1
[01:02.08] INFO: trip_scheduling.i77 7 failed
[01:02.08] INFO: trip_scheduling.i78 scheduling 11 trips within chunk 1
[01:02.16] INFO: trip_scheduling.i78 7 failed
[01:02.16] INFO: trip_scheduling.i79 scheduling 11 trips within chunk 1
[01:02.23] INFO: trip_scheduling.i79 7 failed
[01:02.23] INFO: trip_scheduling.i80 scheduling 11 trips within chunk 1
[01:02.32] INFO: trip_scheduling.i80 7 failed
[01:02.32] INFO: trip_scheduling.i81 scheduling 11 trips within chunk 1
[01:02.40] INFO: trip_scheduling.i81 7 failed
[01:02.40] INFO: trip_scheduling.i82 scheduling 11 trips within chunk 1
[01:02.47] INFO: trip_scheduling.i82 7 failed
[01:02.48] INFO: trip_scheduling.i83 scheduling 11 trips within chunk 1
[01:02.55] INFO: trip_scheduling.i83 7 failed
[01:02.55] INFO: trip_scheduling.i84 scheduling 11 trips within chunk 1
[01:02.63] INFO: trip_scheduling.i84 7 failed
[01:02.63] INFO: trip_scheduling.i85 scheduling 11 trips within chunk 1
[01:02.70] INFO: trip_scheduling.i85 7 failed
[01:02.70] INFO: trip_scheduling.i86 scheduling 11 trips within chunk 1
[01:02.78] INFO: trip_scheduling.i86 7 failed
[01:02.78] INFO: trip_scheduling.i87 scheduling 11 trips within chunk 1
[01:02.85] INFO: trip_scheduling.i87 7 failed
[01:02.85] INFO: trip_scheduling.i88 scheduling 11 trips within chunk 1
[01:02.93] INFO: trip_scheduling.i88 7 failed
[01:02.93] INFO: trip_scheduling.i89 scheduling 11 trips within chunk 1
[01:03.00] INFO: trip_scheduling.i89 7 failed
[01:03.00] INFO: trip_scheduling.i90 scheduling 11 trips within chunk 1
[01:03.08] INFO: trip_scheduling.i90 7 failed
[01:03.08] INFO: trip_scheduling.i91 scheduling 11 trips within chunk 1
[01:03.15] INFO: trip_scheduling.i91 7 failed
[01:03.16] INFO: trip_scheduling.i92 scheduling 11 trips within chunk 1
[01:03.23] INFO: trip_scheduling.i92 7 failed
[01:03.23] INFO: trip_scheduling.i93 scheduling 11 trips within chunk 1
[01:03.31] INFO: trip_scheduling.i93 7 failed
[01:03.31] INFO: trip_scheduling.i94 scheduling 11 trips within chunk 1
[01:03.38] INFO: trip_scheduling.i94 7 failed
[01:03.38] INFO: trip_scheduling.i95 scheduling 11 trips within chunk 1
[01:03.46] INFO: trip_scheduling.i95 7 failed
[01:03.46] INFO: trip_scheduling.i96 scheduling 11 trips within chunk 1
[01:03.53] INFO: trip_scheduling.i96 7 failed
[01:03.53] INFO: trip_scheduling.i97 scheduling 11 trips within chunk 1
[01:03.61] INFO: trip_scheduling.i97 7 failed
[01:03.61] INFO: trip_scheduling.i98 scheduling 11 trips within chunk 1
[01:03.69] INFO: trip_scheduling.i98 7 failed
[01:03.69] INFO: trip_scheduling.i99 scheduling 11 trips within chunk 1
[01:03.76] INFO: trip_scheduling.i99 7 failed
[01:03.76] INFO: trip_scheduling.i100 scheduling 11 trips within chunk 1
[01:03.78] WARNING: trip_scheduling.i100.outbound.num_2 coercing 0 depart choices to most initial
[01:03.79] INFO: dumping trip_scheduling.i100.outbound.num_3.failed_choosers
[01:03.80] WARNING: trip_scheduling.i100.outbound.num_3 coercing 1 depart choices to most initial
[01:03.81] INFO: dumping trip_scheduling.i100.outbound.num_4.failed_choosers
[01:03.81] WARNING: trip_scheduling.i100.outbound.num_4 coercing 1 depart choices to most initial
[01:03.83] INFO: dumping trip_scheduling.i100.inbound.num_1.failed_choosers
[01:03.83] WARNING: trip_scheduling.i100.inbound.num_1 coercing 2 depart choices to most initial
[01:03.84] INFO: dumping trip_scheduling.i100.inbound.num_2.failed_choosers
[01:03.84] WARNING: trip_scheduling.i100.inbound.num_2 coercing 2 depart choices to most initial
[01:03.85] INFO: dumping trip_scheduling.i100.inbound.num_3.failed_choosers
[01:03.85] WARNING: trip_scheduling.i100.inbound.num_3 coercing 1 depart choices to most initial
[01:03.85] INFO: trip_scheduling.i100 0 failed
Time to execute step 'trip_scheduling': 7.71 s
Total time to execute iteration 1 with iteration value None: 7.71 s
[01:03.92] INFO: #run_model running step trip_mode_choice
Running step 'trip_mode_choice'
[01:03.94] INFO: Running trip_mode_choice with 482 trips
[01:03.96] INFO: primary_purpose top 10 value counts:
work        168
shopping     77
othmaint     46
othdiscr     43
school       37
eatout       33
atwork       27
univ         26
social       19
escort        6
Name: primary_purpose, dtype: int64
[01:03.97] INFO: trip_mode_choice tour_type 'atwork' (27 trips)
[01:04.09] INFO: trip_mode_choice.atwork.simple_simulate Running adaptive_chunked_choosers with 27 choosers
[01:04.09] INFO: Running chunk 1 of 1 with 27 of 27 choosers
[01:04.40] WARNING: slice_canonically: no rows in trip_mode_choice.atwork.trip_mode with household_id == [982875]
[01:04.40] INFO: trip_mode_choice tour_type 'eatout' (33 trips)
[01:04.55] INFO: trip_mode_choice.eatout.simple_simulate Running adaptive_chunked_choosers with 33 choosers
[01:04.55] INFO: Running chunk 1 of 1 with 33 of 33 choosers
[01:04.92] INFO: trip_mode_choice tour_type 'escort' (6 trips)
[01:05.04] INFO: trip_mode_choice.escort.simple_simulate Running adaptive_chunked_choosers with 6 choosers
[01:05.04] INFO: Running chunk 1 of 1 with 6 of 6 choosers
[01:05.35] WARNING: slice_canonically: no rows in trip_mode_choice.escort.trip_mode with household_id == [982875]
[01:05.35] INFO: trip_mode_choice tour_type 'othdiscr' (43 trips)
[01:05.47] INFO: trip_mode_choice.othdiscr.simple_simulate Running adaptive_chunked_choosers with 43 choosers
[01:05.47] INFO: Running chunk 1 of 1 with 43 of 43 choosers
[01:05.89] WARNING: slice_canonically: no rows in trip_mode_choice.othdiscr.trip_mode with household_id == [982875]
[01:05.89] INFO: trip_mode_choice tour_type 'othmaint' (46 trips)
[01:06.02] INFO: trip_mode_choice.othmaint.simple_simulate Running adaptive_chunked_choosers with 46 choosers
[01:06.02] INFO: Running chunk 1 of 1 with 46 of 46 choosers
[01:06.46] WARNING: slice_canonically: no rows in trip_mode_choice.othmaint.trip_mode with household_id == [982875]
[01:06.46] INFO: trip_mode_choice tour_type 'school' (37 trips)
[01:06.58] INFO: trip_mode_choice.school.simple_simulate Running adaptive_chunked_choosers with 37 choosers
[01:06.58] INFO: Running chunk 1 of 1 with 37 of 37 choosers
[01:06.89] WARNING: slice_canonically: no rows in trip_mode_choice.school.trip_mode with household_id == [982875]
[01:06.89] INFO: trip_mode_choice tour_type 'shopping' (77 trips)
[01:07.02] INFO: trip_mode_choice.shopping.simple_simulate Running adaptive_chunked_choosers with 77 choosers
[01:07.02] INFO: Running chunk 1 of 1 with 77 of 77 choosers
[01:07.48] WARNING: slice_canonically: no rows in trip_mode_choice.shopping.trip_mode with household_id == [982875]
[01:07.48] INFO: trip_mode_choice tour_type 'social' (19 trips)
[01:07.60] INFO: trip_mode_choice.social.simple_simulate Running adaptive_chunked_choosers with 19 choosers
[01:07.60] INFO: Running chunk 1 of 1 with 19 of 19 choosers
[01:07.99] WARNING: slice_canonically: no rows in trip_mode_choice.social.trip_mode with household_id == [982875]
[01:07.99] INFO: trip_mode_choice tour_type 'univ' (26 trips)
[01:08.13] INFO: trip_mode_choice.univ.simple_simulate Running adaptive_chunked_choosers with 26 choosers
[01:08.13] INFO: Running chunk 1 of 1 with 26 of 26 choosers
[01:08.45] WARNING: slice_canonically: no rows in trip_mode_choice.univ.trip_mode with household_id == [982875]
[01:08.45] INFO: trip_mode_choice tour_type 'work' (168 trips)
[01:08.58] INFO: trip_mode_choice.work.simple_simulate Running adaptive_chunked_choosers with 168 choosers
[01:08.58] INFO: Running chunk 1 of 1 with 168 of 168 choosers
[01:09.07] INFO: trip_modes top 10 value counts:
WALK              211
WALK_LRF           80
WALK_LOC           64
TNC_SINGLE         38
DRIVEALONEFREE     27
BIKE               18
TAXI               15
WALK_HVY           14
SHARED2FREE         6
SHARED3FREE         6
Name: tour_mode, dtype: int64
[01:09.07] INFO: trip_mode_choice choices top 10 value counts:
WALK              304
WALK_LOC           85
WALK_LRF           53
BIKE               17
TNC_SHARED          4
TNC_SINGLE          4
SHARED2FREE         4
WALK_HVY            4
DRIVEALONEFREE      4
TAXI                2
Name: trip_mode, dtype: int64
Time to execute step 'trip_mode_choice': 5.15 s
Total time to execute iteration 1 with iteration value None: 5.15 s
[01:09.14] INFO: #run_model running step write_data_dictionary
Running step 'write_data_dictionary'
Time to execute step 'write_data_dictionary': 0.34 s
Total time to execute iteration 1 with iteration value None: 0.34 s
[01:09.54] INFO: #run_model running step track_skim_usage
Running step 'track_skim_usage'
Time to execute step 'track_skim_usage': 0.00 s
Total time to execute iteration 1 with iteration value None: 0.00 s
[01:09.60] INFO: #run_model running step write_trip_matrices
Running step 'write_trip_matrices'
[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.72] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/core/util.py:365: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[new_columns] = df2[new_columns]

[01:09.73] INFO: adding 'sample_rate' from households to trips table
[01:09.73] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/abm/models/trip_matrices.py:226: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  trips_df[hh_weight_col] = trips_df.household_id.map(household_weights)

[01:09.73] INFO: aggregating trips one zone...
[01:09.74] WARNING: /home/jin/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/abm/models/trip_matrices.py:63: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.
  aggregate_trips = trips_df.groupby(["origin", "destination"], sort=False).sum()

[01:09.75] INFO: opening output/trips_ea.omx
[01:09.77] INFO: adding zone_id mapping for 25 zones to trips_ea.omx
[01:09.77] INFO: closing output/trips_ea.omx
[01:09.77] INFO: opening output/trips_am.omx
[01:09.79] INFO: adding zone_id mapping for 25 zones to trips_am.omx
[01:09.79] INFO: closing output/trips_am.omx
[01:09.79] INFO: opening output/trips_md.omx
[01:09.81] INFO: adding zone_id mapping for 25 zones to trips_md.omx
[01:09.81] INFO: closing output/trips_md.omx
[01:09.82] INFO: opening output/trips_pm.omx
[01:09.84] INFO: adding zone_id mapping for 25 zones to trips_pm.omx
[01:09.84] INFO: closing output/trips_pm.omx
[01:09.84] INFO: opening output/trips_ev.omx
[01:09.86] INFO: adding zone_id mapping for 25 zones to trips_ev.omx
[01:09.86] INFO: closing output/trips_ev.omx
Time to execute step 'write_trip_matrices': 0.27 s
Total time to execute iteration 1 with iteration value None: 0.27 s
[01:09.92] INFO: #run_model running step write_tables
Running step 'write_tables'
Time to execute step 'write_tables': 0.02 s
Total time to execute iteration 1 with iteration value None: 0.02 s
[01:09.99] INFO: #run_model running step summarize
Running step 'summarize'
Time to execute step 'summarize': 0.23 s
Total time to execute iteration 1 with iteration value None: 0.24 s
[01:10.28] INFO: Time to execute run_model (34 models) : 69.21 seconds (1.2 minutes)
[01:10.29] INFO: MainProcess high water mark rss: 237_809_664 (237.8 MB) timestamp: 18/05/2023 11:28:07 label:pipeline.run_model summarize finished
[01:10.29] INFO: MainProcess high water mark uss: 235_859_968 (235.9 MB) timestamp: 18/05/2023 11:28:07 label:pipeline.run_model summarize finished
[01:10.29] INFO: Time to execute all models : 69.252 seconds (1.2 minutes)
(ASIM_DEV_new) jin@rush:~/AVAIL/code/activitysim/activitysim/activitysim_new/activitysim/activitysim/examples/test_prototype_mtc_test$ 
